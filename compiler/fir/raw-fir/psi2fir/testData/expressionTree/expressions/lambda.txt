FILE: lambda.kt
    public? final? data class Tuple : R|kotlin/Any| {
        public? [ContainingClassKey=Tuple] constructor(x: Int, y: Int): R|Tuple| {
            super<R|kotlin/Any|>()
        }

        public? final? [IsFromPrimaryConstructor=true] val x: Int = R|<local>/x|
            public? get(): Int

        public? final? [IsFromPrimaryConstructor=true] val y: Int = R|<local>/y|
            public? get(): Int

        public final operator fun component1(): Int

        public final operator fun component2(): Int

        public final fun copy(x: Int = this@R|/Tuple|.R|/Tuple.x|, y: Int = this@R|/Tuple|.R|/Tuple.y|): R|Tuple|

    }
    public? final? fun expressionTree(block: ( () -> Unit )): R|kotlin/Unit| {
        TODO#(String(intrinsic))
    }
    public? final? inline fun use(f: ( (Tuple) -> Int )): <implicit> {
        ^use firBlock#(listOf#(), listOf#(firQualifiedAccessExpression#(listOf#(), listOf#(), firNoReceiverExpression#(), firNoReceiverExpression#(), firNull#(), firSimpleNamedReference#(firString#(String("f"))))))
    }
    public? final? fun foo(): <implicit> {
        ^foo firBlock#(listOf#(), listOf#(firProperty#(listOf#(), firNull#(), firString#(String("l1")), firImplicitTypeRef#(), firFalse#(), firTrue#(), firNull#(), firNull#()), firQualifiedAccessExpression#(listOf#(), listOf#(), firNoReceiverExpression#(), firNoReceiverExpression#(), firNull#(), firSimpleNamedReference#(firString#(String("use")))), firReturnExpression#(listOf#(), firFunctionTarget#(firString#(String("expressionTree")), firTrue#()), firQualifiedAccessExpression#(listOf#(), listOf#(), firNoReceiverExpression#(), firNoReceiverExpression#(), firNull#(), firSimpleNamedReference#(firString#(String("use")))))))
    }
    public? final? fun bar(): <implicit> {
        ^bar firBlock#(listOf#(), listOf#(firReturnExpression#(listOf#(), firFunctionTarget#(firString#(String("bar")), firFalse#()), firQualifiedAccessExpression#(listOf#(), listOf#(), firNoReceiverExpression#(), firNoReceiverExpression#(), firNull#(), firSimpleNamedReference#(firString#(String("use")))))))
    }
    public? final? fun test(list: List<Int>): <implicit> {
        ^test firBlock#(listOf#(), listOf#(firProperty#(listOf#(), firNull#(), firString#(String("map")), firImplicitTypeRef#(), firFalse#(), firTrue#(), firNull#(), firNull#()), firQualifiedAccessExpression#(listOf#(), listOf#(), firNoReceiverExpression#(), firNoReceiverExpression#(), firQualifiedAccessExpression#(listOf#(), listOf#(), firNoReceiverExpression#(), firNoReceiverExpression#(), firNull#(), firSimpleNamedReference#(firString#(String("list")))), firSimpleNamedReference#(firString#(String("forEach"))))))
    }
    public? final? val simple: <implicit> = firBlock#(listOf#(), listOf#(firAnonymousFunctionExpression#(firAnonymousFunction#(listOf#(), firTrue#(), firImplicitTypeRef#(), listOf#(), firImplicitTypeRef#(), firBlock#(listOf#(), listOf#(firReturnExpression#(listOf#(), firFunctionTarget#(firString#(String("expressionTree")), firTrue#()), firUnitExpression#(listOf#()))))))))
        public? get(): <implicit>
    public? final? val another: <implicit> = firBlock#(listOf#(), listOf#(firAnonymousFunctionExpression#(firAnonymousFunction#(listOf#(), firTrue#(), firImplicitTypeRef#(), listOf#(), firImplicitTypeRef#(), firBlock#(listOf#(), listOf#(firIntegerLiteral#(IntegerLiteral(42))))))))
        public? get(): <implicit>
