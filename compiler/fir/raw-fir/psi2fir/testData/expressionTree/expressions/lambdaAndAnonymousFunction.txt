FILE: lambdaAndAnonymousFunction.kt
    public? final? fun <T> run(block: ( () -> T )): T {
        ^run block#()
    }
    public? final? fun expressionTree(block: ( () -> Unit )): R|kotlin/Unit| {
        TODO#(String(intrinsic))
    }
    public? final? fun test_1(): <implicit> {
        ^test_1 firBlock#(listOf#(), listOf#(firFunctionCall#(listOf#(), listOf#(), Null(null), firNoReceiverExpression#(), firNoReceiverExpression#(), listOf#(firLambdaArgumentExpression#(firAnonymousFunctionExpression#(firAnonymousFunction#(listOf#(), Boolean(true), firImplicitTypeRef#(), listOf#(), firImplicitTypeRef#(), firBlock#(listOf#(), listOf#(firReturnExpression#(listOf#(), firFunctionTarget#(String(run), Boolean(true)), firUnitExpression#(listOf#())))))))), firSimpleNamedReference#(String(run))), firFunctionCall#(listOf#(), listOf#(), Null(null), firNoReceiverExpression#(), firNoReceiverExpression#(), listOf#(firLambdaArgumentExpression#(firAnonymousFunctionExpression#(firAnonymousFunction#(listOf#(), Boolean(true), firImplicitTypeRef#(), listOf#(), firImplicitTypeRef#(), firBlock#(listOf#(), listOf#(firReturnExpression#(listOf#(), firFunctionTarget#(String(expressionTree), Boolean(true)), firUnitExpression#(listOf#())))))))), firSimpleNamedReference#(String(run)))))
    }
    public? final? fun test_2(): <implicit> {
        ^test_2 firBlock#(listOf#(), listOf#(firFunctionCall#(listOf#(), listOf#(), Null(null), firNoReceiverExpression#(), firNoReceiverExpression#(), listOf#(firAnonymousFunctionExpression#(firAnonymousFunction#(listOf#(), Boolean(false), Null(null), listOf#(), firUserTypeRef#(listOf#(), Boolean(false), listOf#(firQualifierPart#(String(Int), listOf#()))), firBlock#(listOf#(), listOf#(firReturnExpression#(listOf#(), firFunctionTarget#(String(run), Boolean(false)), firIntegerLiteral#(IntegerLiteral(1)))))))), firSimpleNamedReference#(String(run)))))
    }
