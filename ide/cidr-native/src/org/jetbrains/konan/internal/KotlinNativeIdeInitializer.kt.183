/*
 * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license
 * that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.konan.internal

import com.intellij.codeInspection.LocalInspectionEP
import com.intellij.ide.util.TipAndTrickBean
import com.intellij.openapi.extensions.ExtensionPoint
import com.intellij.openapi.extensions.ExtensionPointName
import com.intellij.openapi.extensions.Extensions
import com.intellij.task.ProjectTaskRunner
import com.intellij.task.impl.JpsProjectTaskRunner
import org.jetbrains.kotlin.idea.KotlinPluginUtil

/**
 * @author Vladislav.Soroka
 */
@Suppress("SameParameterValue")
class KotlinNativeIdeInitializer {

    private companion object {
        val PLUGINS_TO_UNREGISTER_TIP_AND_TRICKS = setOf(
            KotlinPluginUtil.KOTLIN_PLUGIN_ID.idString, // all tips & tricks that come from the main Kotlin plugin
            "org.intellij.intelliLang", // Java plugin specific
            "com.intellij.diagram" // Java plugin specific
        )
    }

    init {
        // There are groovy local inspections which should not be loaded w/o groovy plugin enabled.
        // Those plugin definitions should become optional and dependant on groovy plugin.
        // This is a temp workaround before it happens.
        unregisterExtensionInstances(LocalInspectionEP.LOCAL_INSPECTION) {
            it.groupDisplayName == "Kotlin" && it.language == "Groovy"
        }

        // Suppress irrelevant tips & tricks
        unregisterExtensionInstances(TipAndTrickBean.EP_NAME) {
            it.pluginId?.idString in PLUGINS_TO_UNREGISTER_TIP_AND_TRICKS
        }

        // Disable JPS
        unregisterExtensionsByClass(ProjectTaskRunner.EP_NAME, JpsProjectTaskRunner::class.java)
    }

    private fun <T : Any> unregisterExtensionsByClass(
        extensionPointName: ExtensionPointName<T>,
        extensionClass: Class<out T>
    ) {
        val extensionPoint = Extensions.getRootArea().getExtensionPoint(extensionPointName)
        unregisterExtensionInstances(extensionPoint, extensionClass::isInstance)
    }

    private fun <T : Any> unregisterExtensionInstances(
        extensionPointName: ExtensionPointName<T>,
        predicate: (T) -> Boolean
    ) {
        val extensionPoint = Extensions.getRootArea().getExtensionPoint(extensionPointName)
        unregisterExtensionInstances(extensionPoint, predicate)
    }

    private fun <T : Any> unregisterExtensionInstances(
        extensionPoint: ExtensionPoint<T>,
        predicate: (T) -> Boolean
    ) {
        val extensionInstancesToUnregister: List<T> = extensionPoint.extensionList.filter(predicate)
        extensionInstancesToUnregister.forEach {
            extensionPoint.unregisterExtension(it)
            extensionPoint.extensionList // to re-initialize caches after removal of one element
        }
    }
}
