package org.jetbrains.konan.resolve

import com.intellij.openapi.Disposable
import com.intellij.openapi.application.ReadAction
import com.intellij.openapi.components.Service
import com.intellij.openapi.components.service
import com.intellij.openapi.fileTypes.FileTypeManager
import com.intellij.openapi.module.Module
import com.intellij.openapi.module.ModuleUtil
import com.intellij.openapi.progress.ProgressManager
import com.intellij.openapi.project.Project
import com.intellij.openapi.vfs.AsyncFileListener
import com.intellij.openapi.vfs.VirtualFile
import com.intellij.openapi.vfs.VirtualFileManager
import com.intellij.openapi.vfs.newvfs.events.*
import com.intellij.psi.search.FileTypeIndex
import com.intellij.util.concurrency.AppExecutorUtil
import com.intellij.util.containers.MultiMap
import com.jetbrains.cidr.lang.symbols.symtable.FileSymbolTable
import com.jetbrains.cidr.lang.symbols.symtable.FileSymbolTablesCache
import com.jetbrains.cidr.lang.symbols.symtable.FileSymbolTablesPackListener
import gnu.trove.THashSet
import gnu.trove.TObjectHash
import kotlinx.collections.immutable.ImmutableList
import kotlinx.collections.immutable.toImmutableList
import org.jetbrains.konan.resolve.symbols.KtDependencyMarker
import org.jetbrains.kotlin.idea.KotlinFileType
import java.util.*

@Service
class KtDependencyGraph(val project: Project) : Disposable {
    private val dependent: MultiMap<VirtualFile, VirtualFile> = MultiMap.createSet()

    @Volatile
    private var invalidationWorkerActive = false
    private val changedFiles: Queue<VirtualFile> = ArrayDeque()
    private val createdFileParents: Queue<VirtualFile> = ArrayDeque()

    init {
        VirtualFileManager.getInstance().addAsyncFileListener(AsyncFileListener { events ->
            val changedFiles = THashSet<VirtualFile>()
            val createdFileParents = THashSet<VirtualFile>()

            for (event in events) {
                ProgressManager.checkCanceled()
                when (event) {
                    is VFileMoveEvent -> if (isRelevant(event.file)) {
                        changedFiles += event.file
                        createdFileParents += event.newParent
                    }
                    is VFileCreateEvent -> if (isRelevant(event.childName)) createdFileParents += event.parent
                    is VFilePropertyChangeEvent -> when {
                        isSymlinkChange(event) -> {
                            if (isRelevant(event.file)) changedFiles += event.file
                        }
                        isFileNameChange(event) -> {
                            if (isRelevant(event.file)) changedFiles += event.file
                            if (isRelevant(event.newValue.toString())) createdFileParents += event.file.parent
                        }
                    }
                    is VFileDeleteEvent -> if (isRelevant(event.file)) changedFiles += event.file
                    is VFileContentChangeEvent -> if (isRelevant(event.file)) changedFiles += event.file
                    is VFileCopyEvent -> if (isRelevant(event.newChildName)) createdFileParents += event.newParent
                }
            }

            if (changedFiles.isEmpty && createdFileParents.isEmpty) return@AsyncFileListener null
            object : AsyncFileListener.ChangeApplier {
                override fun afterVfsChange() {
                    scheduleInvalidation(changedFiles, createdFileParents)
                }
            }
        }, this)
    }

    @Synchronized
    private fun addDependencies(file: VirtualFile, dependencies: TObjectHash<VirtualFile>) {
        dependencies.forEach {
            dependent.putValue(it, file)
            true
        }
    }

    @Synchronized
    private fun removeDependencies(file: VirtualFile, dependencies: TObjectHash<VirtualFile>) {
        dependencies.forEach {
            dependent.remove(it, file)
            true
        }
    }

    private inner class InvalidationWorker : Runnable {
        private val dirtyFiles = THashSet<VirtualFile>()
        private var changedFile: VirtualFile? = null
        private var createdFileParent: VirtualFile? = null

        override fun run() {
            // write action might add new files to queues, so only remember processed files for duration of read action
            val alreadyProcessedFiles = THashSet<VirtualFile>()
            val alreadyProcessedModules = THashSet<Module>()

            while (true) {
                while (true) {
                    ProgressManager.checkCanceled()
                    val file = changedFile
                        ?: synchronized(changedFiles) { changedFiles.poll() }.also { changedFile = it }
                        ?: break

                    if (alreadyProcessedFiles.add(file)) dirtyFiles.addAll(getDependentFiles(file))
                    changedFile = null
                }

                while (true) {
                    ProgressManager.checkCanceled()
                    val parent = createdFileParent
                        ?: synchronized(changedFiles) { createdFileParents.poll() }.also { createdFileParent = it }
                        ?: break

                    ModuleUtil.findModuleForFile(parent, project)?.takeIf { alreadyProcessedModules.add(it) }?.let { module ->
                        //TODO: Is there a better way with LookupTracker?
                        dirtyFiles.addAll(FileTypeIndex.getFiles(KotlinFileType.INSTANCE, module.moduleWithDependentsScope))
                    }
                    createdFileParent = null
                }

                FileSymbolTablesCache.getInstance(project).invalidateDirtyIncludeFiles(dirtyFiles)
                dirtyFiles.clear()

                synchronized(changedFiles) {
                    if (changedFiles.isEmpty() && createdFileParents.isEmpty()) {
                        invalidationWorkerActive = false
                        return@run
                    }
                }
            }
        }
    }

    private fun scheduleInvalidation(newlyChangedFiles: Collection<VirtualFile>, newlyCreatedFileParents: Collection<VirtualFile>) {
        if (newlyChangedFiles.isEmpty() && newlyCreatedFileParents.isEmpty()) return
        synchronized(changedFiles) {
            changedFiles += newlyChangedFiles
            createdFileParents += newlyCreatedFileParents
            if (!invalidationWorkerActive) {
                ReadAction.nonBlocking(InvalidationWorker())
                    .inSmartMode(project)
                    .expireWith(this)
                    .submit(AppExecutorUtil.getAppExecutorService())
                invalidationWorkerActive = true
            }
        }
    }

    @Synchronized
    private fun getDependentFiles(file: VirtualFile): ImmutableList<VirtualFile> = dependent.get(file).toImmutableList()

    class Listener(val project: Project) : FileSymbolTablesPackListener {
        override fun afterTableAddedToPack(table: FileSymbolTable) {
            val marker = table.contents.lastOrNull() as? KtDependencyMarker ?: return
            getInstance(project)
                .addDependencies(table.containingFile, marker.dependencies)
        }

        override fun beforeTableRemovedFromPack(table: FileSymbolTable) {
            val marker = table.contents.lastOrNull() as? KtDependencyMarker ?: return
            getInstance(project)
                .removeDependencies(table.containingFile, marker.dependencies)
        }
    }

    override fun dispose(): Unit = Unit

    companion object {
        fun getInstance(project: Project): KtDependencyGraph = project.service()

        private fun isRelevant(file: VirtualFile): Boolean = FileTypeManager.getInstance().isFileOfType(file, KotlinFileType.INSTANCE)

        private fun isRelevant(name: String): Boolean = FileTypeManager.getInstance().run {
            getFileTypeByFileName(name) === KotlinFileType.INSTANCE && !isFileIgnored(name)
        }

        private fun isFileNameChange(propertyChangeEvent: VFilePropertyChangeEvent): Boolean =
            propertyChangeEvent.propertyName == VirtualFile.PROP_NAME && propertyChangeEvent.oldValue != propertyChangeEvent.newValue

        private fun isSymlinkChange(propertyChangeEvent: VFilePropertyChangeEvent): Boolean =
            propertyChangeEvent.propertyName == VirtualFile.PROP_SYMLINK_TARGET
    }
}