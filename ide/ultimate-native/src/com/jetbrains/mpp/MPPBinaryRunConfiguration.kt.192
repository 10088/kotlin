/*
 * Copyright 2010-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license
 * that can be found in the license/LICENSE.txt file.
 */

package com.jetbrains.mpp

import com.intellij.execution.CommonProgramRunConfigurationParameters
import com.intellij.execution.ExecutionTarget
import com.intellij.execution.Executor
import com.intellij.execution.configuration.EnvironmentVariablesComponent
import com.intellij.execution.configurations.ConfigurationFactory
import com.intellij.execution.configurations.LocatableConfigurationBase
import com.intellij.execution.configurations.RunConfiguration
import com.intellij.execution.configurations.RunProfileState
import com.intellij.execution.runners.ExecutionEnvironment
import com.intellij.openapi.options.SettingsEditor
import com.intellij.openapi.project.Project
import com.jetbrains.cidr.execution.debugger.CidrDebugProfile
import com.jetbrains.konan.WorkspaceXML
import com.jetbrains.mpp.MPPWorkspace
import org.jdom.Element
import org.jetbrains.kotlin.konan.target.HostManager
import javax.swing.Icon

const val DEFAULT_PASS_PARENT_ENVS = true

class MPPBinaryRunConfiguration(
    project: Project,
    factory: ConfigurationFactory,
    var executable: KonanExecutable?
) : LocatableConfigurationBase<Any>(project, factory, executable?.base?.name), CommonProgramRunConfigurationParameters, CidrDebugProfile {

    var selectedTarget: BinaryExecutionTarget? = null

    private var parameters: String? = null
    private var directory: String? = null
    private var envs: MutableMap<String, String>? = null
    private var passPaternalEnvs: Boolean = DEFAULT_PASS_PARENT_ENVS

    fun copyFrom(rhs: MPPBinaryRunConfiguration) {
        executable = rhs.executable
        selectedTarget = rhs.selectedTarget
        parameters = rhs.parameters
        directory = rhs.directory
        envs = rhs.envs
        passPaternalEnvs = rhs.passPaternalEnvs
    }

    override fun getConfigurationEditor(): SettingsEditor<out RunConfiguration> {
        return MPPBinaryRunConfigurationSettingsEditor(project)
    }

    override fun getWorkingDirectory(): String? = directory

    override fun setWorkingDirectory(newDirectory: String?) {
        directory = newDirectory
    }

    override fun getEnvs(): MutableMap<String, String> {
        if (envs == null) envs = LinkedHashMap()
        return envs!!
    }

    override fun setEnvs(newEnvs: MutableMap<String, String>) {
        envs = newEnvs
    }

    override fun isPassParentEnvs(): Boolean = passPaternalEnvs

    override fun setPassParentEnvs(newPassPaternalEnvs: Boolean) {
        passPaternalEnvs = newPassPaternalEnvs
    }

    override fun setProgramParameters(newParameters: String?) {
        parameters = newParameters
    }

    override fun getProgramParameters(): String? = parameters

    override fun getState(executor: Executor, env: ExecutionEnvironment): RunProfileState? {
        val runFile = selectedTarget?.productFile ?: return null
        return KonanCommandLineState(env, this, runFile)
    }

    override fun canRunOn(target: ExecutionTarget): Boolean {
        if (HostManager.host != executable?.base?.targetType) return false
        return target is BinaryExecutionTarget && (executable?.executionTargets?.contains(target) ?: false)
    }

    override fun getIcon(): Icon? = factory?.icon

    override fun readExternal(element: Element) {
        super.readExternal(element)
        val base = KonanExecutableBase.readFromXml(element) ?: return
        executable = MPPWorkspace.getInstance(project).executables.firstOrNull { it.base == base }
        selectedTarget = executable?.executionTargets?.firstOrNull()

        parameters = element.getAttributeValue(WorkspaceXML.RunConfiguration.attributeParameters)
        directory = element.getAttributeValue(WorkspaceXML.RunConfiguration.attributeDirectory)
        passPaternalEnvs = element.getAttributeValue(WorkspaceXML.RunConfiguration.attributePassParent)?.toBoolean() ?: DEFAULT_PASS_PARENT_ENVS
        envs = LinkedHashMap()
        EnvironmentVariablesComponent.readExternal(element, envs)
    }

    override fun writeExternal(element: Element) {
        super.writeExternal(element)
        executable?.base?.writeToXml(element)

        parameters?.let {
            if (it.isNotEmpty()) element.setAttribute(WorkspaceXML.RunConfiguration.attributeParameters, it)
        }
        directory?.let { element.setAttribute(WorkspaceXML.RunConfiguration.attributeDirectory, it) }
        if (passPaternalEnvs != DEFAULT_PASS_PARENT_ENVS) {
            element.setAttribute(WorkspaceXML.RunConfiguration.attributePassParent, passPaternalEnvs.toString())
        }

        envs?.let { EnvironmentVariablesComponent.writeExternal(element, it) }
    }
}