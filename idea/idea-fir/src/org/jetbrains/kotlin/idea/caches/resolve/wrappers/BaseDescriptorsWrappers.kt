/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.idea.caches.resolve.wrappers

import org.jetbrains.kotlin.descriptors.*
import org.jetbrains.kotlin.descriptors.annotations.AnnotationDescriptor
import org.jetbrains.kotlin.descriptors.annotations.Annotations
import org.jetbrains.kotlin.descriptors.impl.AbstractReceiverParameterDescriptor
import org.jetbrains.kotlin.descriptors.impl.ReceiverParameterDescriptorImpl
import org.jetbrains.kotlin.idea.frontend.api.symbols.*
import org.jetbrains.kotlin.idea.frontend.api.symbols.markers.*
import org.jetbrains.kotlin.idea.frontend.api.types.KtType
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.Name
import org.jetbrains.kotlin.name.SpecialNames
import org.jetbrains.kotlin.psi.KtPureElement
import org.jetbrains.kotlin.resolve.constants.*
import org.jetbrains.kotlin.resolve.scopes.MemberScope
import org.jetbrains.kotlin.resolve.scopes.receivers.ExtensionReceiver
import org.jetbrains.kotlin.resolve.scopes.receivers.ImplicitClassReceiver
import org.jetbrains.kotlin.resolve.scopes.receivers.ReceiverValue
import org.jetbrains.kotlin.resolve.source.toSourceElement
import org.jetbrains.kotlin.storage.StorageManager
import org.jetbrains.kotlin.types.*
import org.jetbrains.kotlin.utils.addToStdlib.safeAs

/**
 * Legend:
 *  - where was decided, that KtSymbolBased descriptor is not support method, noImplementation() method is called.
 *  - where the implementation planned, but not yet here: implementationPlanned()
 *  - if there is no simple implementation and it isn't clear if it really needed -- implementationPostponed()
 *  - if there were no investigation -- autogenerated TODO("not implemented") called
 */
internal fun noImplementation(additionalInfo: String): Nothing = error("This method should not be called for wrappers. $additionalInfo")
internal fun implementationPostponed(additionalInfo: String): Nothing = TODO("InvestigateLater and implement if needed. $additionalInfo")
internal fun implementationPlanned(additionalInfo: String): Nothing = TODO("SE_to_implement. $additionalInfo")

/**
 * List of known problems/not-implemented:
 * - getOrigin return itself all the time. Formally it should return "unsubstituted" version of itself, but it isn't clear,
 *      if we really needed that nor how to implemented it. Btw, it is relevant only to member functions/properties (unlikely, but may be to
 *      inner classes) and not for "resulting descriptor". I.e. only class/interface type parameters could be substituted in FIR,
 *      there is no "resulting descriptor" and type arguments are passed together with the target function.
 * - equals on descriptors and type constructors. It isn't clear what type of equality we should implement,
 *      will figure that later o real cases.
 * See the functions below
 */

internal fun containerDeclarationImplementationPostponed(): Nothing =
    implementationPostponed("It isn't clear what we really need and how to implement it")

internal fun typeAliasImplementationPlanned(): Nothing = implementationPlanned("It is easy to implement, but it isn't first priority")

interface KtSymbolBasedNamed : Named {
    val ktSymbol: KtNamedSymbol
    override fun getName(): Name = ktSymbol.name
}

abstract class KtSymbolBasedDeclarationDescriptor : DeclarationDescriptorWithSource {
    abstract val ktSymbol: KtSymbol
    override val annotations: Annotations
        get() {
            val ktAnnotations = (ktSymbol as? KtAnnotatedSymbol)?.annotations ?: return Annotations.EMPTY
            return Annotations.create(ktAnnotations.map(::KtSymbolBasedAnnotationDescriptor))
        }

    override fun getSource(): SourceElement = ktSymbol.psi.safeAs<KtPureElement>().toSourceElement()

    override fun <R : Any?, D : Any?> accept(visitor: DeclarationDescriptorVisitor<R, D>?, data: D): R = noImplementation()
    override fun acceptVoid(visitor: DeclarationDescriptorVisitor<Void, Void>?): Unit = noImplementation()

    // stub for automatic Substitutable<T> implementation for all relevant subclasses
    fun substitute(substitutor: TypeSubstitutor): Nothing = noImplementation()

    protected fun noImplementation(): Nothing = noImplementation("ktSymbol = $ktSymbol")
    protected fun implementationPostponed(): Nothing = implementationPostponed("ktSymbol = $ktSymbol")
    protected fun implementationPlanned(): Nothing = implementationPlanned("ktSymbol = $ktSymbol")
}


class KtSymbolBasedAnnotationDescriptor(
    private val ktAnnotationCall: KtAnnotationCall
) : AnnotationDescriptor {
    override val type: KotlinType
        get() = implementationPlanned("ktAnnotationCall = $ktAnnotationCall")

    override val fqName: FqName?
        get() = ktAnnotationCall.classId?.asSingleFqName()

    override val allValueArguments: Map<Name, ConstantValue<*>> =
        ktAnnotationCall.arguments.associate { Name.identifier(it.name) to it.expression.toConstantValue() }

    override val source: SourceElement
        get() = ktAnnotationCall.psi.toSourceElement()
}

private fun KtConstantValue.toConstantValue(): ConstantValue<*> =
    when (this) {
        KtUnsupportedConstantValue -> ErrorValue.create("Error value for KtUnsupportedConstantValue")
        is KtSimpleConstantValue<*> -> when (val value = constant) {
            null -> NullValue()
            is Boolean -> BooleanValue(value)
            is Char -> CharValue(value)
            is Byte -> ByteValue(value)
            is Short -> ShortValue(value)
            is Int -> IntValue(value)
            is Long -> LongValue(value)
            is String -> StringValue(value)
            is Float -> FloatValue(value)
            is Double -> DoubleValue(value)
            else -> error("Unexpected constant KtSimpleConstantValue: $value (class: ${value.javaClass}")
        }
        is KtUnsignedConstantValue<*> -> when (val value = runtimeConstant) {
            is Byte -> UByteValue(value)
            is Short -> UShortValue(value)
            is Int -> UIntValue(value)
            is Long -> ULongValue(value)
            else -> error("Unexpected constant KtSimpleConstantValue: $value (class: ${value?.javaClass}")
        }
    }

private fun KtSymbolVisibility.toDescriptorVisibility(): DescriptorVisibility =
    when (this) {
        KtSymbolVisibility.PUBLIC -> DescriptorVisibilities.PUBLIC
        KtSymbolVisibility.PRIVATE -> DescriptorVisibilities.PRIVATE
        KtSymbolVisibility.PRIVATE_TO_THIS -> DescriptorVisibilities.PRIVATE_TO_THIS
        KtSymbolVisibility.PROTECTED -> DescriptorVisibilities.PROTECTED
        KtSymbolVisibility.INTERNAL -> DescriptorVisibilities.INTERNAL
        KtSymbolVisibility.LOCAL -> DescriptorVisibilities.LOCAL
        KtSymbolVisibility.UNKNOWN -> DescriptorVisibilities.UNKNOWN
    }

private fun KtSymbolModality.toDescriptorModality(): Modality =
    when (this) {
        KtSymbolModality.SEALED -> Modality.SEALED
        KtCommonSymbolModality.FINAL -> Modality.FINAL
        KtCommonSymbolModality.ABSTRACT -> Modality.ABSTRACT
        KtCommonSymbolModality.OPEN -> Modality.OPEN
    }

private fun KtClassKind.toDescriptorKlassKind(): ClassKind =
    when (this) {
        KtClassKind.CLASS -> ClassKind.CLASS
        KtClassKind.ENUM_CLASS -> ClassKind.ENUM_CLASS
        KtClassKind.ENUM_ENTRY -> ClassKind.ENUM_ENTRY
        KtClassKind.ANNOTATION_CLASS -> ClassKind.ANNOTATION_CLASS
        KtClassKind.OBJECT, KtClassKind.COMPANION_OBJECT -> ClassKind.OBJECT
        KtClassKind.INTERFACE -> ClassKind.INTERFACE
    }

class KtSymbolBasedClassDescriptor(override val ktSymbol: KtClassOrObjectSymbol) :
    KtSymbolBasedDeclarationDescriptor(), KtSymbolBasedNamed, ClassDescriptor {

    override fun isInner(): Boolean = ktSymbol.isInner
    override fun isCompanionObject(): Boolean = ktSymbol.isCompanion
    override fun isData(): Boolean = ktSymbol.isData
    override fun isInline(): Boolean = ktSymbol.isInline // seems like this flag should be removed in favor of isValue
    override fun isValue(): Boolean = ktSymbol.isInline
    override fun isFun(): Boolean = ktSymbol.isFun

    override fun isExpect(): Boolean = ktSymbol.isExpect
    override fun isActual(): Boolean = ktSymbol.isActual
    override fun isExternal(): Boolean = ktSymbol.isExternal

    override fun getVisibility(): DescriptorVisibility = ktSymbol.visibility.toDescriptorVisibility()
    override fun getModality(): Modality = ktSymbol.modality.toDescriptorModality()

    override fun getKind(): ClassKind = ktSymbol.classKind.toDescriptorKlassKind()

    override fun getCompanionObjectDescriptor(): ClassDescriptor? = ktSymbol.companionObject?.let { KtSymbolBasedClassDescriptor(it) }

    override fun getTypeConstructor(): TypeConstructor = KtSymbolBasedClassTypeConstructor(this)

    override fun getDeclaredTypeParameters(): List<TypeParameterDescriptor> =
        ktSymbol.typeParameters.map { KtSymbolBasedTypeParameterDescriptor(it) }

    override fun getDefaultType(): SimpleType {
        val arguments = TypeUtils.getDefaultTypeProjections(typeConstructor.parameters)
        return KotlinTypeFactory.simpleTypeWithNonTrivialMemberScope(
            Annotations.EMPTY, typeConstructor, arguments, false,
            MemberScopeForKtSymbolBasedDescriptors { "ktSymbol = $ktSymbol" }
        )
    }

    override fun getThisAsReceiverParameter(): ReceiverParameterDescriptor =
        ReceiverParameterDescriptorImpl(this, ImplicitClassReceiver(this), Annotations.EMPTY)

    override fun getOriginal(): ClassDescriptor = this

    override fun getUnsubstitutedPrimaryConstructor(): ClassConstructorDescriptor? = ktSymbol.primaryConstructor?.let {
        KtSymbolBasedConstructorDescriptor(it, this)
    }

    @OptIn(ExperimentalStdlibApi::class)
    override fun getConstructors(): Collection<ClassConstructorDescriptor> = buildList {
        ktSymbol.primaryConstructor?.let { add(KtSymbolBasedConstructorDescriptor(it, this@KtSymbolBasedClassDescriptor)) }
        ktSymbol.secondaryConstructors.forEach {
            add(KtSymbolBasedConstructorDescriptor(it, this@KtSymbolBasedClassDescriptor))
        }
    }

    override fun getContainingDeclaration(): DeclarationDescriptor = containerDeclarationImplementationPostponed()

    override fun getSealedSubclasses(): Collection<ClassDescriptor> = implementationPostponed()

    override fun getMemberScope(typeArguments: MutableList<out TypeProjection>): MemberScope = noImplementation()
    override fun getMemberScope(typeSubstitution: TypeSubstitution): MemberScope = noImplementation()
    override fun getUnsubstitutedMemberScope(): MemberScope = noImplementation()
    override fun getUnsubstitutedInnerClassesScope(): MemberScope = noImplementation()
    override fun getStaticScope(): MemberScope = noImplementation()

    override fun isDefinitelyNotSamInterface(): Boolean = noImplementation()
    override fun getDefaultFunctionTypeForSamInterface(): SimpleType = noImplementation()
}

class KtSymbolBasedTypeParameterDescriptor(
    override val ktSymbol: KtTypeParameterSymbol
) : KtSymbolBasedDeclarationDescriptor(), KtSymbolBasedNamed, TypeParameterDescriptor {
    override fun isReified(): Boolean = ktSymbol.isReified
    override fun getVariance(): Variance = ktSymbol.variance

    override fun getTypeConstructor(): TypeConstructor = KtSymbolBasedTypeParameterTypeConstructor(this)

    override fun getDefaultType(): SimpleType =
        KotlinTypeFactory.simpleTypeWithNonTrivialMemberScope(
            Annotations.EMPTY, typeConstructor, emptyList(), false,
            MemberScopeForKtSymbolBasedDescriptors { "ktSymbol = $ktSymbol" }
        )

    override fun getUpperBounds(): List<KotlinType> = ktSymbol.upperBounds.map(KtType::toKotlinType)
    override fun getOriginal(): TypeParameterDescriptor = this

    override fun getContainingDeclaration(): DeclarationDescriptor = containerDeclarationImplementationPostponed()

    // there is no such thing in FIR, and it seems like it isn't really needed for IDE and could be bypassed on client site
    override fun getIndex(): Int = implementationPostponed()

    override fun isCapturedFromOuterDeclaration(): Boolean = noImplementation()
    override fun getStorageManager(): StorageManager = noImplementation()
}

abstract class KtSymbolBasedFunctionLikeDescriptor() :
    KtSymbolBasedDeclarationDescriptor(), FunctionDescriptor {
    abstract override val ktSymbol: KtFunctionLikeSymbol


    override fun getVisibility(): DescriptorVisibility {
        TODO("Not yet implemented")
    }

    override fun getTypeParameters(): List<TypeParameterDescriptor> {
        TODO("Not yet implemented")
    }

    override fun getReturnType(): KotlinType? {
        TODO("Not yet implemented")
    }

    override fun getValueParameters(): MutableList<ValueParameterDescriptor> {
        TODO("Not yet implemented")
    }

    override fun hasStableParameterNames(): Boolean {
        TODO("Not yet implemented")
    }

    override fun hasSynthesizedParameterNames(): Boolean {
        TODO("Not yet implemented")
    }


    override fun getModality(): Modality {
        TODO("Not yet implemented")
    }

    override fun isExpect(): Boolean {
        TODO("Not yet implemented")
    }

    override fun isActual(): Boolean {
        TODO("Not yet implemented")
    }

    override fun isExternal(): Boolean {
        TODO("Not yet implemented")
    }

    override fun getKind(): CallableMemberDescriptor.Kind {
        TODO("Not yet implemented")
    }


    override fun isOperator(): Boolean {
        TODO("Not yet implemented")
    }

    override fun isInfix(): Boolean {
        TODO("Not yet implemented")
    }

    override fun isInline(): Boolean {
        TODO("Not yet implemented")
    }

    override fun isTailrec(): Boolean {
        TODO("Not yet implemented")
    }

    override fun isSuspend(): Boolean {
        TODO("Not yet implemented")
    }

    override fun <V : Any?> getUserData(key: CallableDescriptor.UserDataKey<V>?): V? = null

    override fun getOriginal(): FunctionDescriptor = this
    override fun getContainingDeclaration(): DeclarationDescriptor = containerDeclarationImplementationPostponed()

    override fun getOverriddenDescriptors(): MutableCollection<out FunctionDescriptor> = implementationPostponed()
    override fun isHiddenForResolutionEverywhereBesideSupercalls(): Boolean = implementationPostponed()

    override fun getInitialSignatureDescriptor(): FunctionDescriptor? = noImplementation()
    override fun isHiddenToOvercomeSignatureClash(): Boolean = noImplementation()

    override fun setOverriddenDescriptors(overriddenDescriptors: MutableCollection<out CallableMemberDescriptor>) = noImplementation()
    override fun newCopyBuilder(): FunctionDescriptor.CopyBuilder<out FunctionDescriptor> = noImplementation()
    override fun copy(
        newOwner: DeclarationDescriptor?,
        modality: Modality?,
        visibility: DescriptorVisibility?,
        kind: CallableMemberDescriptor.Kind?,
        copyOverrides: Boolean
    ): FunctionDescriptor = noImplementation()
}

class KtSymbolBasedFunctionDescriptor(override val ktSymbol: KtFunctionSymbol) : KtSymbolBasedFunctionLikeDescriptor(), KtSymbolBasedNamed {
    override fun getExtensionReceiverParameter(): ReceiverParameterDescriptor? = getExtensionReceiverParameter(ktSymbol)
    override fun getDispatchReceiverParameter(): ReceiverParameterDescriptor? = getDispatchReceiverParameter(ktSymbol)
}

class KtSymbolBasedConstructorDescriptor(
    override val ktSymbol: KtConstructorSymbol,
    private val ktSBClassDescriptor: KtSymbolBasedClassDescriptor
) : KtSymbolBasedFunctionLikeDescriptor(),
    ClassConstructorDescriptor {
    override fun getName(): Name = Name.special("<init>")

    override fun getExtensionReceiverParameter(): ReceiverParameterDescriptor? = null
    override fun getDispatchReceiverParameter(): ReceiverParameterDescriptor? = getDispatchReceiverParameter(ktSymbol)

    override fun getConstructedClass(): ClassDescriptor = ktSBClassDescriptor
    override fun isPrimary(): Boolean = ktSymbol.isPrimary

    override fun getReturnType(): KotlinType = ktSBClassDescriptor.defaultType

    override fun getOriginal(): ClassConstructorDescriptor = this
    override fun getContainingDeclaration(): ClassDescriptor = ktSBClassDescriptor

    override fun copy(
        newOwner: DeclarationDescriptor,
        modality: Modality,
        visibility: DescriptorVisibility,
        kind: CallableMemberDescriptor.Kind,
        copyOverrides: Boolean
    ): ClassConstructorDescriptor = noImplementation()
}

class KtSymbolBasedAnonymousDescriptor(override val ktSymbol: KtAnonymousFunctionSymbol) : KtSymbolBasedFunctionLikeDescriptor() {
    override fun getName(): Name = SpecialNames.ANONYMOUS_FUNCTION

    override fun getExtensionReceiverParameter(): ReceiverParameterDescriptor? = getExtensionReceiverParameter(ktSymbol)
    override fun getDispatchReceiverParameter(): ReceiverParameterDescriptor? = null
}

private fun CallableDescriptor.getDispatchReceiverParameter(ktSymbol: KtPossibleMemberSymbol): ReceiverParameterDescriptor? {
    val ktDispatchTypeAndAnnotations = ktSymbol.dispatchType ?: return null
    return KtSymbolStubDispatchReceiverParameterDescriptor(ktDispatchTypeAndAnnotations.type)
}

private fun CallableDescriptor.getExtensionReceiverParameter(ktSymbol: KtPossibleExtensionSymbol): ReceiverParameterDescriptor? {
    val receiverTypeAndAnnotation = ktSymbol.receiverType ?: return null
    val receiverValue = ExtensionReceiver(this, receiverTypeAndAnnotation.type.toKotlinType(), null)
    return ReceiverParameterDescriptorImpl(this, receiverValue, receiverTypeAndAnnotation.getDescriptorsAnnotations())
}

private class KtSymbolBasedReceiverValue(val ktType: KtType) : ReceiverValue {
    override fun getType(): KotlinType = ktType.toKotlinType()

    override fun replaceType(newType: KotlinType): ReceiverValue = noImplementation("Should be called from IDE")
    override fun getOriginal(): ReceiverValue = this
}

// Don't think that annotation is important here, because containingDeclaration used way more then annotation and they are not supported here
private class KtSymbolStubDispatchReceiverParameterDescriptor(val receiverType: KtType) :
    AbstractReceiverParameterDescriptor(Annotations.EMPTY) {
    override fun getContainingDeclaration(): DeclarationDescriptor = containerDeclarationImplementationPostponed()

    override fun getValue(): ReceiverValue = KtSymbolBasedReceiverValue(receiverType)

    override fun copy(newOwner: DeclarationDescriptor): ReceiverParameterDescriptor =
        noImplementation("Copy should be called from IDE code")
}