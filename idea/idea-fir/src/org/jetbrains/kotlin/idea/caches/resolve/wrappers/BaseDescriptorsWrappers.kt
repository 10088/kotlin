/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.idea.caches.resolve.wrappers

import org.jetbrains.kotlin.descriptors.*
import org.jetbrains.kotlin.descriptors.annotations.AnnotationDescriptor
import org.jetbrains.kotlin.descriptors.annotations.Annotations
import org.jetbrains.kotlin.idea.frontend.api.symbols.KtClassKind
import org.jetbrains.kotlin.idea.frontend.api.symbols.KtClassOrObjectSymbol
import org.jetbrains.kotlin.idea.frontend.api.symbols.markers.*
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.Name
import org.jetbrains.kotlin.psi.KtPureElement
import org.jetbrains.kotlin.resolve.constants.*
import org.jetbrains.kotlin.resolve.scopes.MemberScope
import org.jetbrains.kotlin.resolve.source.toSourceElement
import org.jetbrains.kotlin.types.*
import org.jetbrains.kotlin.utils.addToStdlib.safeAs


/**
 * Legend:
 *  - where was decided, that KtSymbolBased descriptor is not support method, noImplementation() method is called.
 *  - where the implementation planned, but not yet here: implementationPlanned()
 *  - if there were no investigation -- autogenerated TODO("not implemented") called
 */


abstract class KtSymbolBasedDeclarationDescriptor<T : KtNamedSymbol>(val ktSymbol: T) : DeclarationDescriptorWithSource {
    override val annotations: Annotations
        get() {
            val ktAnnotations = (ktSymbol as? KtAnnotatedSymbol)?.annotations ?: return Annotations.EMPTY
            return Annotations.create(ktAnnotations.map(::KtSymbolBasedAnnotationDescriptor))
        }

    override fun getName(): Name = ktSymbol.name
    override fun getSource(): SourceElement = ktSymbol.psi.safeAs<KtPureElement>().toSourceElement()

    override fun <R : Any?, D : Any?> accept(visitor: DeclarationDescriptorVisitor<R, D>?, data: D): R = noImplementation()
    override fun acceptVoid(visitor: DeclarationDescriptorVisitor<Void, Void>?): Unit = noImplementation()

    // stub for automatic Substitutable<T> implementation for all relevant subclasses
    fun substitute(substitutor: TypeSubstitutor): Nothing = noImplementation()

    protected fun noImplementation(): Nothing =
        error("This method should not be called for KtSymbolBasedDeclaration. ktSymbol = $ktSymbol")

    protected fun implementationPlanned(): Nothing = TODO("SE_to_implement, ktSymbol = $ktSymbol")
}


class KtSymbolBasedAnnotationDescriptor(
    private val ktAnnotationCall: KtAnnotationCall
) : AnnotationDescriptor {
    override val type: KotlinType
        get() = TODO("SEImplement")

    override val fqName: FqName?
        get() = ktAnnotationCall.classId?.asSingleFqName()

    override val allValueArguments: Map<Name, ConstantValue<*>> =
        ktAnnotationCall.arguments.associate { Name.identifier(it.name) to it.expression.toConstantValue() }

    override val source: SourceElement
        get() = ktAnnotationCall.psi.toSourceElement()
}

private fun KtConstantValue.toConstantValue(): ConstantValue<*> =
    when (this) {
        KtUnsupportedConstantValue -> ErrorValue.create("Error value for KtUnsupportedConstantValue")
        is KtSimpleConstantValue<*> -> when (val value = constant) {
            null -> NullValue()
            is Boolean -> BooleanValue(value)
            is Char -> CharValue(value)
            is Byte -> ByteValue(value)
            is Short -> ShortValue(value)
            is Int -> IntValue(value)
            is Long -> LongValue(value)
            is String -> StringValue(value)
            is Float -> FloatValue(value)
            is Double -> DoubleValue(value)
            else -> error("Unexpected constant KtSimpleConstantValue: $value (class: ${value.javaClass}")
        }
        is KtUnsignedConstantValue<*> -> when (val value = runtimeConstant) {
            is Byte -> UByteValue(value)
            is Short -> UShortValue(value)
            is Int -> UIntValue(value)
            is Long -> ULongValue(value)
            else -> error("Unexpected constant KtSimpleConstantValue: $value (class: ${value?.javaClass}")
        }
    }

private fun KtSymbolVisibility.toDescriptorVisibility(): DescriptorVisibility =
    when (this) {
        KtSymbolVisibility.PUBLIC -> DescriptorVisibilities.PUBLIC
        KtSymbolVisibility.PRIVATE -> DescriptorVisibilities.PRIVATE
        KtSymbolVisibility.PRIVATE_TO_THIS -> DescriptorVisibilities.PRIVATE_TO_THIS
        KtSymbolVisibility.PROTECTED -> DescriptorVisibilities.PROTECTED
        KtSymbolVisibility.INTERNAL -> DescriptorVisibilities.INTERNAL
        KtSymbolVisibility.LOCAL -> DescriptorVisibilities.LOCAL
        KtSymbolVisibility.UNKNOWN -> DescriptorVisibilities.UNKNOWN
    }

private fun KtSymbolModality.toDescriptorModality(): Modality =
    when (this) {
        KtSymbolModality.SEALED -> Modality.SEALED
        KtCommonSymbolModality.FINAL -> Modality.FINAL
        KtCommonSymbolModality.ABSTRACT -> Modality.ABSTRACT
        KtCommonSymbolModality.OPEN -> Modality.OPEN
    }

private fun KtClassKind.toDescriptorKlassKind(): ClassKind =
    when(this) {
        KtClassKind.CLASS -> ClassKind.CLASS
        KtClassKind.ENUM_CLASS -> ClassKind.ENUM_CLASS
        KtClassKind.ENUM_ENTRY -> ClassKind.ENUM_ENTRY
        KtClassKind.ANNOTATION_CLASS -> ClassKind.ANNOTATION_CLASS
        KtClassKind.OBJECT, KtClassKind.COMPANION_OBJECT -> ClassKind.OBJECT
        KtClassKind.INTERFACE -> ClassKind.INTERFACE
    }

class KtSymbolBasedClassDescriptor(ktSymbol: KtClassOrObjectSymbol) :
    KtSymbolBasedDeclarationDescriptor<KtClassOrObjectSymbol>(ktSymbol), ClassDescriptor {

    override fun isInner(): Boolean = ktSymbol.isInner
    override fun isCompanionObject(): Boolean = ktSymbol.isCompanion
    override fun isData(): Boolean = ktSymbol.isData
    override fun isInline(): Boolean = ktSymbol.isInline // seems like this flag should be removed in favor of isValue
    override fun isValue(): Boolean = ktSymbol.isInline
    override fun isFun(): Boolean = ktSymbol.isFun

    override fun getVisibility(): DescriptorVisibility = ktSymbol.visibility.toDescriptorVisibility()
    override fun getModality(): Modality = ktSymbol.modality.toDescriptorModality()
    override fun getKind(): ClassKind = ktSymbol.classKind.toDescriptorKlassKind()

    override fun getCompanionObjectDescriptor(): ClassDescriptor? = ktSymbol.companionObject?.let { KtSymbolBasedClassDescriptor(it) }

    override fun getTypeConstructor(): TypeConstructor {
        TODO("Not yet implemented")
    }

    override fun getDefaultType(): SimpleType {
        TODO("Not yet implemented")
    }

    override fun isExpect(): Boolean {
        TODO("Not yet implemented")
    }

    override fun isActual(): Boolean {
        TODO("Not yet implemented")
    }

    override fun isExternal(): Boolean {
        TODO("Not yet implemented")
    }


    override fun getDeclaredTypeParameters(): List<TypeParameterDescriptor> {
        TODO("Not yet implemented")
    }

    override fun getMemberScope(typeArguments: MutableList<out TypeProjection>): MemberScope {
        TODO("Not yet implemented")
    }

    override fun getMemberScope(typeSubstitution: TypeSubstitution): MemberScope {
        TODO("Not yet implemented")
    }

    override fun getUnsubstitutedMemberScope(): MemberScope {
        TODO("Not yet implemented")
    }

    override fun getUnsubstitutedInnerClassesScope(): MemberScope {
        TODO("Not yet implemented")
    }

    override fun getStaticScope(): MemberScope {
        TODO("Not yet implemented")
    }

    override fun getConstructors(): Collection<ClassConstructorDescriptor> {
        TODO("Not yet implemented")
    }

    override fun getThisAsReceiverParameter(): ReceiverParameterDescriptor {
        TODO("Not yet implemented")
    }

    override fun getUnsubstitutedPrimaryConstructor(): ClassConstructorDescriptor? {
        TODO("Not yet implemented")
    }

    override fun getSealedSubclasses(): Collection<ClassDescriptor> {
        TODO("Not yet implemented")
    }


    override fun getOriginal(): ClassDescriptor = implementationPlanned()
    override fun getContainingDeclaration(): DeclarationDescriptor = implementationPlanned()

    override fun isDefinitelyNotSamInterface(): Boolean =
        error("Shouldn't be called for wrapped descriptor")

    override fun getDefaultFunctionTypeForSamInterface(): SimpleType? =
        error("Shouldn't be called for wrapped descriptor")

}

