/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.idea.caches.resolve.wrappers

import org.jetbrains.kotlin.descriptors.*
import org.jetbrains.kotlin.descriptors.annotations.AnnotationDescriptor
import org.jetbrains.kotlin.descriptors.annotations.Annotations
import org.jetbrains.kotlin.idea.frontend.api.symbols.KtClassKind
import org.jetbrains.kotlin.idea.frontend.api.symbols.KtClassOrObjectSymbol
import org.jetbrains.kotlin.idea.frontend.api.symbols.KtTypeParameterSymbol
import org.jetbrains.kotlin.idea.frontend.api.symbols.markers.*
import org.jetbrains.kotlin.idea.frontend.api.types.KtType
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.Name
import org.jetbrains.kotlin.psi.KtPureElement
import org.jetbrains.kotlin.resolve.constants.*
import org.jetbrains.kotlin.resolve.scopes.MemberScope
import org.jetbrains.kotlin.resolve.source.toSourceElement
import org.jetbrains.kotlin.storage.StorageManager
import org.jetbrains.kotlin.types.*
import org.jetbrains.kotlin.utils.addToStdlib.safeAs

/**
 * Legend:
 *  - where was decided, that KtSymbolBased descriptor is not support method, noImplementation() method is called.
 *  - where the implementation planned, but not yet here: implementationPlanned()
 *  - if there is no simple implementation and it isn't clear if it really needed -- implementationPostponed()
 *  - if there were no investigation -- autogenerated TODO("not implemented") called
 */
internal fun noImplementation(additionalInfo: String): Nothing = error("This method should not be called for wrappers. $additionalInfo")
internal fun implementationPostponed(additionalInfo: String): Nothing = TODO("InvestigateLater and implement if needed. $additionalInfo")
internal fun implementationPlanned(additionalInfo: String): Nothing = TODO("SE_to_implement. $additionalInfo")

/**
 * List of known problems/not-implemented:
 * - getOrigin return itself all the time. Formally it should return "unsubstituted" version of itself, but it isn't clear,
 *      if we really needed that nor how to implemented it. Btw, it is relevant only to member functions/properties (unlikely, but may be to
 *      inner classes) and not for "resulting descriptor". I.e. only class/interface type parameters could be substituted in FIR,
 *      there is no "resulting descriptor" and type arguments are passed together with the target function.
 * - equals on descriptors and type constructors. It isn't clear what type of equality we should implement,
 *      will figure that later o real cases.
 * See the functions below
 */

internal fun containerDeclarationImplementationPostponed(): Nothing =
    implementationPostponed("It isn't clear what we really need and how to implement it")

internal fun typeAliasImplementationPlanned(): Nothing = implementationPlanned("It is easy to implement, but it isn't first priority")

abstract class KtSymbolBasedDeclarationDescriptor<T : KtNamedSymbol>(val ktSymbol: T) : DeclarationDescriptorWithSource {
    override val annotations: Annotations
        get() {
            val ktAnnotations = (ktSymbol as? KtAnnotatedSymbol)?.annotations ?: return Annotations.EMPTY
            return Annotations.create(ktAnnotations.map(::KtSymbolBasedAnnotationDescriptor))
        }

    override fun getName(): Name = ktSymbol.name
    override fun getSource(): SourceElement = ktSymbol.psi.safeAs<KtPureElement>().toSourceElement()

    override fun <R : Any?, D : Any?> accept(visitor: DeclarationDescriptorVisitor<R, D>?, data: D): R = noImplementation()
    override fun acceptVoid(visitor: DeclarationDescriptorVisitor<Void, Void>?): Unit = noImplementation()

    // stub for automatic Substitutable<T> implementation for all relevant subclasses
    fun substitute(substitutor: TypeSubstitutor): Nothing = noImplementation()

    protected fun noImplementation(): Nothing = noImplementation("ktSymbol = $ktSymbol")
    protected fun implementationPostponed(): Nothing = implementationPostponed("ktSymbol = $ktSymbol")
    protected fun implementationPlanned(): Nothing = implementationPlanned("ktSymbol = $ktSymbol")
}


class KtSymbolBasedAnnotationDescriptor(
    private val ktAnnotationCall: KtAnnotationCall
) : AnnotationDescriptor {
    override val type: KotlinType
        get() = implementationPlanned("ktAnnotationCall = $ktAnnotationCall")

    override val fqName: FqName?
        get() = ktAnnotationCall.classId?.asSingleFqName()

    override val allValueArguments: Map<Name, ConstantValue<*>> =
        ktAnnotationCall.arguments.associate { Name.identifier(it.name) to it.expression.toConstantValue() }

    override val source: SourceElement
        get() = ktAnnotationCall.psi.toSourceElement()
}

private fun KtConstantValue.toConstantValue(): ConstantValue<*> =
    when (this) {
        KtUnsupportedConstantValue -> ErrorValue.create("Error value for KtUnsupportedConstantValue")
        is KtSimpleConstantValue<*> -> when (val value = constant) {
            null -> NullValue()
            is Boolean -> BooleanValue(value)
            is Char -> CharValue(value)
            is Byte -> ByteValue(value)
            is Short -> ShortValue(value)
            is Int -> IntValue(value)
            is Long -> LongValue(value)
            is String -> StringValue(value)
            is Float -> FloatValue(value)
            is Double -> DoubleValue(value)
            else -> error("Unexpected constant KtSimpleConstantValue: $value (class: ${value.javaClass}")
        }
        is KtUnsignedConstantValue<*> -> when (val value = runtimeConstant) {
            is Byte -> UByteValue(value)
            is Short -> UShortValue(value)
            is Int -> UIntValue(value)
            is Long -> ULongValue(value)
            else -> error("Unexpected constant KtSimpleConstantValue: $value (class: ${value?.javaClass}")
        }
    }

private fun KtSymbolVisibility.toDescriptorVisibility(): DescriptorVisibility =
    when (this) {
        KtSymbolVisibility.PUBLIC -> DescriptorVisibilities.PUBLIC
        KtSymbolVisibility.PRIVATE -> DescriptorVisibilities.PRIVATE
        KtSymbolVisibility.PRIVATE_TO_THIS -> DescriptorVisibilities.PRIVATE_TO_THIS
        KtSymbolVisibility.PROTECTED -> DescriptorVisibilities.PROTECTED
        KtSymbolVisibility.INTERNAL -> DescriptorVisibilities.INTERNAL
        KtSymbolVisibility.LOCAL -> DescriptorVisibilities.LOCAL
        KtSymbolVisibility.UNKNOWN -> DescriptorVisibilities.UNKNOWN
    }

private fun KtSymbolModality.toDescriptorModality(): Modality =
    when (this) {
        KtSymbolModality.SEALED -> Modality.SEALED
        KtCommonSymbolModality.FINAL -> Modality.FINAL
        KtCommonSymbolModality.ABSTRACT -> Modality.ABSTRACT
        KtCommonSymbolModality.OPEN -> Modality.OPEN
    }

private fun KtClassKind.toDescriptorKlassKind(): ClassKind =
    when(this) {
        KtClassKind.CLASS -> ClassKind.CLASS
        KtClassKind.ENUM_CLASS -> ClassKind.ENUM_CLASS
        KtClassKind.ENUM_ENTRY -> ClassKind.ENUM_ENTRY
        KtClassKind.ANNOTATION_CLASS -> ClassKind.ANNOTATION_CLASS
        KtClassKind.OBJECT, KtClassKind.COMPANION_OBJECT -> ClassKind.OBJECT
        KtClassKind.INTERFACE -> ClassKind.INTERFACE
    }

class KtSymbolBasedClassDescriptor(ktSymbol: KtClassOrObjectSymbol) :
    KtSymbolBasedDeclarationDescriptor<KtClassOrObjectSymbol>(ktSymbol), ClassDescriptor {

    override fun isInner(): Boolean = ktSymbol.isInner
    override fun isCompanionObject(): Boolean = ktSymbol.isCompanion
    override fun isData(): Boolean = ktSymbol.isData
    override fun isInline(): Boolean = ktSymbol.isInline // seems like this flag should be removed in favor of isValue
    override fun isValue(): Boolean = ktSymbol.isInline
    override fun isFun(): Boolean = ktSymbol.isFun

    override fun isExpect(): Boolean = ktSymbol.isExpect
    override fun isActual(): Boolean = ktSymbol.isActual
    override fun isExternal(): Boolean = ktSymbol.isExternal

    override fun getVisibility(): DescriptorVisibility = ktSymbol.visibility.toDescriptorVisibility()
    override fun getModality(): Modality = ktSymbol.modality.toDescriptorModality()

    override fun getKind(): ClassKind = ktSymbol.classKind.toDescriptorKlassKind()

    override fun getCompanionObjectDescriptor(): ClassDescriptor? = ktSymbol.companionObject?.let { KtSymbolBasedClassDescriptor(it) }

    override fun getTypeConstructor(): TypeConstructor = KtSymbolBasedClassTypeConstructor(this)

    override fun getDeclaredTypeParameters(): List<TypeParameterDescriptor> =
        ktSymbol.typeParameters.map { KtSymbolBasedTypeParameterDescriptor(it) }

    override fun getDefaultType(): SimpleType {
        val arguments = TypeUtils.getDefaultTypeProjections(typeConstructor.parameters)
        return KotlinTypeFactory.simpleTypeWithNonTrivialMemberScope(
            Annotations.EMPTY, typeConstructor, arguments, false,
            MemberScopeForKtSymbolBasedDescriptors { "ktSymbol = $ktSymbol" }
        )
    }

    override fun getOriginal(): ClassDescriptor = this

    override fun getUnsubstitutedPrimaryConstructor(): ClassConstructorDescriptor? = implementationPlanned()
    override fun getConstructors(): Collection<ClassConstructorDescriptor> = implementationPlanned()
    override fun getThisAsReceiverParameter(): ReceiverParameterDescriptor = implementationPlanned()
    override fun getContainingDeclaration(): DeclarationDescriptor = containerDeclarationImplementationPostponed()

    override fun getSealedSubclasses(): Collection<ClassDescriptor> = implementationPostponed()

    override fun getMemberScope(typeArguments: MutableList<out TypeProjection>): MemberScope = noImplementation()
    override fun getMemberScope(typeSubstitution: TypeSubstitution): MemberScope = noImplementation()
    override fun getUnsubstitutedMemberScope(): MemberScope = noImplementation()
    override fun getUnsubstitutedInnerClassesScope(): MemberScope = noImplementation()
    override fun getStaticScope(): MemberScope = noImplementation()

    override fun isDefinitelyNotSamInterface(): Boolean = noImplementation()
    override fun getDefaultFunctionTypeForSamInterface(): SimpleType = noImplementation()
}

class KtSymbolBasedTypeParameterDescriptor(
    ktSymbol: KtTypeParameterSymbol
) : KtSymbolBasedDeclarationDescriptor<KtTypeParameterSymbol>(ktSymbol), TypeParameterDescriptor {
    override fun isReified(): Boolean = ktSymbol.isReified
    override fun getVariance(): Variance = ktSymbol.variance

    override fun getTypeConstructor(): TypeConstructor = KtSymbolBasedTypeParameterTypeConstructor(this)

    override fun getDefaultType(): SimpleType =
        KotlinTypeFactory.simpleTypeWithNonTrivialMemberScope(
            Annotations.EMPTY, typeConstructor, emptyList(), false,
            MemberScopeForKtSymbolBasedDescriptors { "ktSymbol = $ktSymbol" }
        )

    override fun getUpperBounds(): List<KotlinType> = ktSymbol.upperBounds.map(KtType::toKotlinType)
    override fun getOriginal(): TypeParameterDescriptor = this

    override fun getContainingDeclaration(): DeclarationDescriptor = containerDeclarationImplementationPostponed()

    // there is no such thing in FIR, and it seems like it isn't really needed for IDE and could be bypassed on client site
    override fun getIndex(): Int = implementationPostponed()

    override fun isCapturedFromOuterDeclaration(): Boolean = noImplementation()
    override fun getStorageManager(): StorageManager = noImplementation()
}
