public inline fun kotlin.BooleanArray.reduceRightIndexed(/*0*/ operation: (index: kotlin.Int, kotlin.Boolean, acc: kotlin.Boolean) -> kotlin.Boolean): kotlin.Boolean
public inline fun kotlin.ByteArray.reduceRightIndexed(/*0*/ operation: (index: kotlin.Int, kotlin.Byte, acc: kotlin.Byte) -> kotlin.Byte): kotlin.Byte
public inline fun kotlin.CharArray.reduceRightIndexed(/*0*/ operation: (index: kotlin.Int, kotlin.Char, acc: kotlin.Char) -> kotlin.Char): kotlin.Char
public inline fun kotlin.DoubleArray.reduceRightIndexed(/*0*/ operation: (index: kotlin.Int, kotlin.Double, acc: kotlin.Double) -> kotlin.Double): kotlin.Double
public inline fun kotlin.FloatArray.reduceRightIndexed(/*0*/ operation: (index: kotlin.Int, kotlin.Float, acc: kotlin.Float) -> kotlin.Float): kotlin.Float
public inline fun kotlin.IntArray.reduceRightIndexed(/*0*/ operation: (index: kotlin.Int, kotlin.Int, acc: kotlin.Int) -> kotlin.Int): kotlin.Int
public inline fun kotlin.LongArray.reduceRightIndexed(/*0*/ operation: (index: kotlin.Int, kotlin.Long, acc: kotlin.Long) -> kotlin.Long): kotlin.Long
public inline fun kotlin.ShortArray.reduceRightIndexed(/*0*/ operation: (index: kotlin.Int, kotlin.Short, acc: kotlin.Short) -> kotlin.Short): kotlin.Short
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UByteArray.reduceRightIndexed(/*0*/ operation: (index: kotlin.Int, kotlin.UByte, acc: kotlin.UByte) -> kotlin.UByte): kotlin.UByte
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UIntArray.reduceRightIndexed(/*0*/ operation: (index: kotlin.Int, kotlin.UInt, acc: kotlin.UInt) -> kotlin.UInt): kotlin.UInt
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ULongArray.reduceRightIndexed(/*0*/ operation: (index: kotlin.Int, kotlin.ULong, acc: kotlin.ULong) -> kotlin.ULong): kotlin.ULong
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UShortArray.reduceRightIndexed(/*0*/ operation: (index: kotlin.Int, kotlin.UShort, acc: kotlin.UShort) -> kotlin.UShort): kotlin.UShort
public inline fun </*0*/ S, /*1*/ T : S> kotlin.collections.List<T>.reduceRightIndexed(/*0*/ operation: (index: kotlin.Int, T, acc: S) -> S): S
@kotlin.SinceKotlin(version = "1.4") public inline fun </*0*/ S, /*1*/ T : S> kotlin.Array<out T>.reduceRightIndexedOrNull(/*0*/ operation: (index: kotlin.Int, T, acc: S) -> S): S?
@kotlin.SinceKotlin(version = "1.4") public inline fun kotlin.BooleanArray.reduceRightIndexedOrNull(/*0*/ operation: (index: kotlin.Int, kotlin.Boolean, acc: kotlin.Boolean) -> kotlin.Boolean): kotlin.Boolean?
@kotlin.SinceKotlin(version = "1.4") public inline fun kotlin.ByteArray.reduceRightIndexedOrNull(/*0*/ operation: (index: kotlin.Int, kotlin.Byte, acc: kotlin.Byte) -> kotlin.Byte): kotlin.Byte?
@kotlin.SinceKotlin(version = "1.4") public inline fun kotlin.CharArray.reduceRightIndexedOrNull(/*0*/ operation: (index: kotlin.Int, kotlin.Char, acc: kotlin.Char) -> kotlin.Char): kotlin.Char?
@kotlin.SinceKotlin(version = "1.4") public inline fun kotlin.DoubleArray.reduceRightIndexedOrNull(/*0*/ operation: (index: kotlin.Int, kotlin.Double, acc: kotlin.Double) -> kotlin.Double): kotlin.Double?
@kotlin.SinceKotlin(version = "1.4") public inline fun kotlin.FloatArray.reduceRightIndexedOrNull(/*0*/ operation: (index: kotlin.Int, kotlin.Float, acc: kotlin.Float) -> kotlin.Float): kotlin.Float?
@kotlin.SinceKotlin(version = "1.4") public inline fun kotlin.IntArray.reduceRightIndexedOrNull(/*0*/ operation: (index: kotlin.Int, kotlin.Int, acc: kotlin.Int) -> kotlin.Int): kotlin.Int?
@kotlin.SinceKotlin(version = "1.4") public inline fun kotlin.LongArray.reduceRightIndexedOrNull(/*0*/ operation: (index: kotlin.Int, kotlin.Long, acc: kotlin.Long) -> kotlin.Long): kotlin.Long?
@kotlin.SinceKotlin(version = "1.4") public inline fun kotlin.ShortArray.reduceRightIndexedOrNull(/*0*/ operation: (index: kotlin.Int, kotlin.Short, acc: kotlin.Short) -> kotlin.Short): kotlin.Short?
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UByteArray.reduceRightIndexedOrNull(/*0*/ operation: (index: kotlin.Int, kotlin.UByte, acc: kotlin.UByte) -> kotlin.UByte): kotlin.UByte?
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UIntArray.reduceRightIndexedOrNull(/*0*/ operation: (index: kotlin.Int, kotlin.UInt, acc: kotlin.UInt) -> kotlin.UInt): kotlin.UInt?
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ULongArray.reduceRightIndexedOrNull(/*0*/ operation: (index: kotlin.Int, kotlin.ULong, acc: kotlin.ULong) -> kotlin.ULong): kotlin.ULong?
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UShortArray.reduceRightIndexedOrNull(/*0*/ operation: (index: kotlin.Int, kotlin.UShort, acc: kotlin.UShort) -> kotlin.UShort): kotlin.UShort?
@kotlin.SinceKotlin(version = "1.4") public inline fun </*0*/ S, /*1*/ T : S> kotlin.collections.List<T>.reduceRightIndexedOrNull(/*0*/ operation: (index: kotlin.Int, T, acc: S) -> S): S?
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi public inline fun </*0*/ S, /*1*/ T : S> kotlin.Array<out T>.reduceRightOrNull(/*0*/ operation: (T, acc: S) -> S): S?
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi public inline fun kotlin.BooleanArray.reduceRightOrNull(/*0*/ operation: (kotlin.Boolean, acc: kotlin.Boolean) -> kotlin.Boolean): kotlin.Boolean?
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi public inline fun kotlin.ByteArray.reduceRightOrNull(/*0*/ operation: (kotlin.Byte, acc: kotlin.Byte) -> kotlin.Byte): kotlin.Byte?
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi public inline fun kotlin.CharArray.reduceRightOrNull(/*0*/ operation: (kotlin.Char, acc: kotlin.Char) -> kotlin.Char): kotlin.Char?
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi public inline fun kotlin.DoubleArray.reduceRightOrNull(/*0*/ operation: (kotlin.Double, acc: kotlin.Double) -> kotlin.Double): kotlin.Double?
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi public inline fun kotlin.FloatArray.reduceRightOrNull(/*0*/ operation: (kotlin.Float, acc: kotlin.Float) -> kotlin.Float): kotlin.Float?
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi public inline fun kotlin.IntArray.reduceRightOrNull(/*0*/ operation: (kotlin.Int, acc: kotlin.Int) -> kotlin.Int): kotlin.Int?
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi public inline fun kotlin.LongArray.reduceRightOrNull(/*0*/ operation: (kotlin.Long, acc: kotlin.Long) -> kotlin.Long): kotlin.Long?
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi public inline fun kotlin.ShortArray.reduceRightOrNull(/*0*/ operation: (kotlin.Short, acc: kotlin.Short) -> kotlin.Short): kotlin.Short?
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UByteArray.reduceRightOrNull(/*0*/ operation: (kotlin.UByte, acc: kotlin.UByte) -> kotlin.UByte): kotlin.UByte?
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UIntArray.reduceRightOrNull(/*0*/ operation: (kotlin.UInt, acc: kotlin.UInt) -> kotlin.UInt): kotlin.UInt?
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ULongArray.reduceRightOrNull(/*0*/ operation: (kotlin.ULong, acc: kotlin.ULong) -> kotlin.ULong): kotlin.ULong?
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UShortArray.reduceRightOrNull(/*0*/ operation: (kotlin.UShort, acc: kotlin.UShort) -> kotlin.UShort): kotlin.UShort?
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi public inline fun </*0*/ S, /*1*/ T : S> kotlin.collections.List<T>.reduceRightOrNull(/*0*/ operation: (T, acc: S) -> S): S?
@kotlin.SinceKotlin(version = "1.1") public inline fun </*0*/ S, /*1*/ T : S, /*2*/ K, /*3*/ M : kotlin.collections.MutableMap<in K, S>> kotlin.collections.Grouping<T, K>.reduceTo(/*0*/ destination: M, /*1*/ operation: (key: K, accumulator: S, element: T) -> S): M
@kotlin.internal.InlineOnly public inline fun </*0*/ @kotlin.internal.OnlyInputTypes T> kotlin.collections.MutableCollection<out T>.remove(/*0*/ element: T): kotlin.Boolean
@kotlin.Deprecated(level = DeprecationLevel.ERROR, message = "Use removeAt(index) instead.", replaceWith = kotlin.ReplaceWith(expression = "removeAt(index)", imports = {})) @kotlin.internal.InlineOnly public inline fun </*0*/ T> kotlin.collections.MutableList<T>.remove(/*0*/ index: kotlin.Int): T
@kotlin.internal.InlineOnly public inline fun </*0*/ @kotlin.internal.OnlyInputTypes K, /*1*/ V> kotlin.collections.MutableMap<out K, V>.remove(/*0*/ key: K): V?
public fun </*0*/ T> kotlin.collections.MutableCollection<in T>.removeAll(/*0*/ elements: kotlin.Array<out T>): kotlin.Boolean
public fun </*0*/ T> kotlin.collections.MutableCollection<in T>.removeAll(/*0*/ elements: kotlin.collections.Iterable<T>): kotlin.Boolean
public fun </*0*/ T> kotlin.collections.MutableCollection<in T>.removeAll(/*0*/ elements: kotlin.sequences.Sequence<T>): kotlin.Boolean
@kotlin.internal.InlineOnly public inline fun </*0*/ @kotlin.internal.OnlyInputTypes T> kotlin.collections.MutableCollection<out T>.removeAll(/*0*/ elements: kotlin.collections.Collection<T>): kotlin.Boolean
public fun </*0*/ T> kotlin.collections.MutableIterable<T>.removeAll(/*0*/ predicate: (T) -> kotlin.Boolean): kotlin.Boolean
public fun </*0*/ T> kotlin.collections.MutableList<T>.removeAll(/*0*/ predicate: (T) -> kotlin.Boolean): kotlin.Boolean
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi public fun </*0*/ T> kotlin.collections.MutableList<T>.removeFirst(): T
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi public fun </*0*/ T> kotlin.collections.MutableList<T>.removeFirstOrNull(): T?
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi public fun </*0*/ T> kotlin.collections.MutableList<T>.removeLast(): T
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi public fun </*0*/ T> kotlin.collections.MutableList<T>.removeLastOrNull(): T?
public fun </*0*/ T : kotlin.Any> kotlin.Array<T?>.requireNoNulls(): kotlin.Array<T>
public fun </*0*/ T : kotlin.Any> kotlin.collections.Iterable<T?>.requireNoNulls(): kotlin.collections.Iterable<T>
public fun </*0*/ T : kotlin.Any> kotlin.collections.List<T?>.requireNoNulls(): kotlin.collections.List<T>
public fun </*0*/ T> kotlin.collections.MutableCollection<in T>.retainAll(/*0*/ elements: kotlin.Array<out T>): kotlin.Boolean
public fun </*0*/ T> kotlin.collections.MutableCollection<in T>.retainAll(/*0*/ elements: kotlin.collections.Iterable<T>): kotlin.Boolean
public fun </*0*/ T> kotlin.collections.MutableCollection<in T>.retainAll(/*0*/ elements: kotlin.sequences.Sequence<T>): kotlin.Boolean
@kotlin.internal.InlineOnly public inline fun </*0*/ @kotlin.internal.OnlyInputTypes T> kotlin.collections.MutableCollection<out T>.retainAll(/*0*/ elements: kotlin.collections.Collection<T>): kotlin.Boolean
public fun </*0*/ T> kotlin.collections.MutableIterable<T>.retainAll(/*0*/ predicate: (T) -> kotlin.Boolean): kotlin.Boolean
public fun </*0*/ T> kotlin.collections.MutableList<T>.retainAll(/*0*/ predicate: (T) -> kotlin.Boolean): kotlin.Boolean
public fun </*0*/ T> kotlin.Array<T>.reverse(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun </*0*/ T> kotlin.Array<T>.reverse(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
public fun kotlin.BooleanArray.reverse(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.BooleanArray.reverse(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
public fun kotlin.ByteArray.reverse(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.ByteArray.reverse(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
public fun kotlin.CharArray.reverse(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.CharArray.reverse(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
public fun kotlin.DoubleArray.reverse(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.DoubleArray.reverse(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
public fun kotlin.FloatArray.reverse(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.FloatArray.reverse(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
public fun kotlin.IntArray.reverse(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.IntArray.reverse(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
public fun kotlin.LongArray.reverse(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.LongArray.reverse(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
public fun kotlin.ShortArray.reverse(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.ShortArray.reverse(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UByteArray.reverse(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UByteArray.reverse(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UIntArray.reverse(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UIntArray.reverse(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ULongArray.reverse(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ULongArray.reverse(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UShortArray.reverse(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UShortArray.reverse(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
public fun </*0*/ T> kotlin.collections.MutableList<T>.reverse(): kotlin.Unit
public fun </*0*/ T> kotlin.Array<out T>.reversed(): kotlin.collections.List<T>
public fun kotlin.BooleanArray.reversed(): kotlin.collections.List<kotlin.Boolean>
public fun kotlin.ByteArray.reversed(): kotlin.collections.List<kotlin.Byte>
public fun kotlin.CharArray.reversed(): kotlin.collections.List<kotlin.Char>
public fun kotlin.DoubleArray.reversed(): kotlin.collections.List<kotlin.Double>
public fun kotlin.FloatArray.reversed(): kotlin.collections.List<kotlin.Float>
public fun kotlin.IntArray.reversed(): kotlin.collections.List<kotlin.Int>
public fun kotlin.LongArray.reversed(): kotlin.collections.List<kotlin.Long>
public fun kotlin.ShortArray.reversed(): kotlin.collections.List<kotlin.Short>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.reversed(): kotlin.collections.List<kotlin.UByte>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.reversed(): kotlin.collections.List<kotlin.UInt>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.reversed(): kotlin.collections.List<kotlin.ULong>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.reversed(): kotlin.collections.List<kotlin.UShort>
public fun </*0*/ T> kotlin.collections.Iterable<T>.reversed(): kotlin.collections.List<T>
public fun </*0*/ T> kotlin.Array<T>.reversedArray(): kotlin.Array<T>
public fun kotlin.BooleanArray.reversedArray(): kotlin.BooleanArray
public fun kotlin.ByteArray.reversedArray(): kotlin.ByteArray
public fun kotlin.CharArray.reversedArray(): kotlin.CharArray
public fun kotlin.DoubleArray.reversedArray(): kotlin.DoubleArray
public fun kotlin.FloatArray.reversedArray(): kotlin.FloatArray
public fun kotlin.IntArray.reversedArray(): kotlin.IntArray
public fun kotlin.LongArray.reversedArray(): kotlin.LongArray
public fun kotlin.ShortArray.reversedArray(): kotlin.ShortArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UByteArray.reversedArray(): kotlin.UByteArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UIntArray.reversedArray(): kotlin.UIntArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ULongArray.reversedArray(): kotlin.ULongArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UShortArray.reversedArray(): kotlin.UShortArray
@kotlin.SinceKotlin(version = "1.4") public inline fun </*0*/ T, /*1*/ R> kotlin.Array<out T>.runningFold(/*0*/ initial: R, /*1*/ operation: (acc: R, T) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.4") @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.BooleanArray.runningFold(/*0*/ initial: R, /*1*/ operation: (acc: R, kotlin.Boolean) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.4") @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.ByteArray.runningFold(/*0*/ initial: R, /*1*/ operation: (acc: R, kotlin.Byte) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.4") @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.CharArray.runningFold(/*0*/ initial: R, /*1*/ operation: (acc: R, kotlin.Char) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.4") @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.DoubleArray.runningFold(/*0*/ initial: R, /*1*/ operation: (acc: R, kotlin.Double) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.4") @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.FloatArray.runningFold(/*0*/ initial: R, /*1*/ operation: (acc: R, kotlin.Float) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.4") @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.IntArray.runningFold(/*0*/ initial: R, /*1*/ operation: (acc: R, kotlin.Int) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.4") @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.LongArray.runningFold(/*0*/ initial: R, /*1*/ operation: (acc: R, kotlin.Long) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.4") @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.ShortArray.runningFold(/*0*/ initial: R, /*1*/ operation: (acc: R, kotlin.Short) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.UByteArray.runningFold(/*0*/ initial: R, /*1*/ operation: (acc: R, kotlin.UByte) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.UIntArray.runningFold(/*0*/ initial: R, /*1*/ operation: (acc: R, kotlin.UInt) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.ULongArray.runningFold(/*0*/ initial: R, /*1*/ operation: (acc: R, kotlin.ULong) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.UShortArray.runningFold(/*0*/ initial: R, /*1*/ operation: (acc: R, kotlin.UShort) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.4") public inline fun </*0*/ T, /*1*/ R> kotlin.collections.Iterable<T>.runningFold(/*0*/ initial: R, /*1*/ operation: (acc: R, T) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.4") public inline fun </*0*/ T, /*1*/ R> kotlin.Array<out T>.runningFoldIndexed(/*0*/ initial: R, /*1*/ operation: (index: kotlin.Int, acc: R, T) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.4") @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.BooleanArray.runningFoldIndexed(/*0*/ initial: R, /*1*/ operation: (index: kotlin.Int, acc: R, kotlin.Boolean) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.4") @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.ByteArray.runningFoldIndexed(/*0*/ initial: R, /*1*/ operation: (index: kotlin.Int, acc: R, kotlin.Byte) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.4") @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.CharArray.runningFoldIndexed(/*0*/ initial: R, /*1*/ operation: (index: kotlin.Int, acc: R, kotlin.Char) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.4") @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.DoubleArray.runningFoldIndexed(/*0*/ initial: R, /*1*/ operation: (index: kotlin.Int, acc: R, kotlin.Double) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.4") @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.FloatArray.runningFoldIndexed(/*0*/ initial: R, /*1*/ operation: (index: kotlin.Int, acc: R, kotlin.Float) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.4") @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.IntArray.runningFoldIndexed(/*0*/ initial: R, /*1*/ operation: (index: kotlin.Int, acc: R, kotlin.Int) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.4") @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.LongArray.runningFoldIndexed(/*0*/ initial: R, /*1*/ operation: (index: kotlin.Int, acc: R, kotlin.Long) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.4") @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.ShortArray.runningFoldIndexed(/*0*/ initial: R, /*1*/ operation: (index: kotlin.Int, acc: R, kotlin.Short) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.UByteArray.runningFoldIndexed(/*0*/ initial: R, /*1*/ operation: (index: kotlin.Int, acc: R, kotlin.UByte) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.UIntArray.runningFoldIndexed(/*0*/ initial: R, /*1*/ operation: (index: kotlin.Int, acc: R, kotlin.UInt) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.ULongArray.runningFoldIndexed(/*0*/ initial: R, /*1*/ operation: (index: kotlin.Int, acc: R, kotlin.ULong) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.UShortArray.runningFoldIndexed(/*0*/ initial: R, /*1*/ operation: (index: kotlin.Int, acc: R, kotlin.UShort) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.4") public inline fun </*0*/ T, /*1*/ R> kotlin.collections.Iterable<T>.runningFoldIndexed(/*0*/ initial: R, /*1*/ operation: (index: kotlin.Int, acc: R, T) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi public inline fun </*0*/ S, /*1*/ T : S> kotlin.Array<out T>.runningReduce(/*0*/ operation: (acc: S, T) -> S): kotlin.collections.List<S>
@kotlin.SinceKotlin(version = "1.4") @kotlin.internal.InlineOnly public inline fun kotlin.BooleanArray.runningReduce(/*0*/ operation: (acc: kotlin.Boolean, kotlin.Boolean) -> kotlin.Boolean): kotlin.collections.List<kotlin.Boolean>
@kotlin.SinceKotlin(version = "1.4") @kotlin.internal.InlineOnly public inline fun kotlin.ByteArray.runningReduce(/*0*/ operation: (acc: kotlin.Byte, kotlin.Byte) -> kotlin.Byte): kotlin.collections.List<kotlin.Byte>
@kotlin.SinceKotlin(version = "1.4") @kotlin.internal.InlineOnly public inline fun kotlin.CharArray.runningReduce(/*0*/ operation: (acc: kotlin.Char, kotlin.Char) -> kotlin.Char): kotlin.collections.List<kotlin.Char>
@kotlin.SinceKotlin(version = "1.4") @kotlin.internal.InlineOnly public inline fun kotlin.DoubleArray.runningReduce(/*0*/ operation: (acc: kotlin.Double, kotlin.Double) -> kotlin.Double): kotlin.collections.List<kotlin.Double>
@kotlin.SinceKotlin(version = "1.4") @kotlin.internal.InlineOnly public inline fun kotlin.FloatArray.runningReduce(/*0*/ operation: (acc: kotlin.Float, kotlin.Float) -> kotlin.Float): kotlin.collections.List<kotlin.Float>
@kotlin.SinceKotlin(version = "1.4") @kotlin.internal.InlineOnly public inline fun kotlin.IntArray.runningReduce(/*0*/ operation: (acc: kotlin.Int, kotlin.Int) -> kotlin.Int): kotlin.collections.List<kotlin.Int>
@kotlin.SinceKotlin(version = "1.4") @kotlin.internal.InlineOnly public inline fun kotlin.LongArray.runningReduce(/*0*/ operation: (acc: kotlin.Long, kotlin.Long) -> kotlin.Long): kotlin.collections.List<kotlin.Long>
@kotlin.SinceKotlin(version = "1.4") @kotlin.internal.InlineOnly public inline fun kotlin.ShortArray.runningReduce(/*0*/ operation: (acc: kotlin.Short, kotlin.Short) -> kotlin.Short): kotlin.collections.List<kotlin.Short>
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UByteArray.runningReduce(/*0*/ operation: (acc: kotlin.UByte, kotlin.UByte) -> kotlin.UByte): kotlin.collections.List<kotlin.UByte>
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UIntArray.runningReduce(/*0*/ operation: (acc: kotlin.UInt, kotlin.UInt) -> kotlin.UInt): kotlin.collections.List<kotlin.UInt>
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ULongArray.runningReduce(/*0*/ operation: (acc: kotlin.ULong, kotlin.ULong) -> kotlin.ULong): kotlin.collections.List<kotlin.ULong>
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UShortArray.runningReduce(/*0*/ operation: (acc: kotlin.UShort, kotlin.UShort) -> kotlin.UShort): kotlin.collections.List<kotlin.UShort>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi public inline fun </*0*/ S, /*1*/ T : S> kotlin.collections.Iterable<T>.runningReduce(/*0*/ operation: (acc: S, T) -> S): kotlin.collections.List<S>
@kotlin.SinceKotlin(version = "1.4") public inline fun </*0*/ S, /*1*/ T : S> kotlin.Array<out T>.runningReduceIndexed(/*0*/ operation: (index: kotlin.Int, acc: S, T) -> S): kotlin.collections.List<S>
@kotlin.SinceKotlin(version = "1.4") @kotlin.internal.InlineOnly public inline fun kotlin.BooleanArray.runningReduceIndexed(/*0*/ operation: (index: kotlin.Int, acc: kotlin.Boolean, kotlin.Boolean) -> kotlin.Boolean): kotlin.collections.List<kotlin.Boolean>
@kotlin.SinceKotlin(version = "1.4") @kotlin.internal.InlineOnly public inline fun kotlin.ByteArray.runningReduceIndexed(/*0*/ operation: (index: kotlin.Int, acc: kotlin.Byte, kotlin.Byte) -> kotlin.Byte): kotlin.collections.List<kotlin.Byte>
@kotlin.SinceKotlin(version = "1.4") @kotlin.internal.InlineOnly public inline fun kotlin.CharArray.runningReduceIndexed(/*0*/ operation: (index: kotlin.Int, acc: kotlin.Char, kotlin.Char) -> kotlin.Char): kotlin.collections.List<kotlin.Char>
@kotlin.SinceKotlin(version = "1.4") @kotlin.internal.InlineOnly public inline fun kotlin.DoubleArray.runningReduceIndexed(/*0*/ operation: (index: kotlin.Int, acc: kotlin.Double, kotlin.Double) -> kotlin.Double): kotlin.collections.List<kotlin.Double>
@kotlin.SinceKotlin(version = "1.4") @kotlin.internal.InlineOnly public inline fun kotlin.FloatArray.runningReduceIndexed(/*0*/ operation: (index: kotlin.Int, acc: kotlin.Float, kotlin.Float) -> kotlin.Float): kotlin.collections.List<kotlin.Float>
@kotlin.SinceKotlin(version = "1.4") @kotlin.internal.InlineOnly public inline fun kotlin.IntArray.runningReduceIndexed(/*0*/ operation: (index: kotlin.Int, acc: kotlin.Int, kotlin.Int) -> kotlin.Int): kotlin.collections.List<kotlin.Int>
@kotlin.SinceKotlin(version = "1.4") @kotlin.internal.InlineOnly public inline fun kotlin.LongArray.runningReduceIndexed(/*0*/ operation: (index: kotlin.Int, acc: kotlin.Long, kotlin.Long) -> kotlin.Long): kotlin.collections.List<kotlin.Long>
@kotlin.SinceKotlin(version = "1.4") @kotlin.internal.InlineOnly public inline fun kotlin.ShortArray.runningReduceIndexed(/*0*/ operation: (index: kotlin.Int, acc: kotlin.Short, kotlin.Short) -> kotlin.Short): kotlin.collections.List<kotlin.Short>
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UByteArray.runningReduceIndexed(/*0*/ operation: (index: kotlin.Int, acc: kotlin.UByte, kotlin.UByte) -> kotlin.UByte): kotlin.collections.List<kotlin.UByte>
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UIntArray.runningReduceIndexed(/*0*/ operation: (index: kotlin.Int, acc: kotlin.UInt, kotlin.UInt) -> kotlin.UInt): kotlin.collections.List<kotlin.UInt>
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ULongArray.runningReduceIndexed(/*0*/ operation: (index: kotlin.Int, acc: kotlin.ULong, kotlin.ULong) -> kotlin.ULong): kotlin.collections.List<kotlin.ULong>
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UShortArray.runningReduceIndexed(/*0*/ operation: (index: kotlin.Int, acc: kotlin.UShort, kotlin.UShort) -> kotlin.UShort): kotlin.collections.List<kotlin.UShort>
@kotlin.SinceKotlin(version = "1.4") public inline fun </*0*/ S, /*1*/ T : S> kotlin.collections.Iterable<T>.runningReduceIndexed(/*0*/ operation: (index: kotlin.Int, acc: S, T) -> S): kotlin.collections.List<S>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi public inline fun </*0*/ T, /*1*/ R> kotlin.Array<out T>.scan(/*0*/ initial: R, /*1*/ operation: (acc: R, T) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.BooleanArray.scan(/*0*/ initial: R, /*1*/ operation: (acc: R, kotlin.Boolean) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.ByteArray.scan(/*0*/ initial: R, /*1*/ operation: (acc: R, kotlin.Byte) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.CharArray.scan(/*0*/ initial: R, /*1*/ operation: (acc: R, kotlin.Char) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.DoubleArray.scan(/*0*/ initial: R, /*1*/ operation: (acc: R, kotlin.Double) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.FloatArray.scan(/*0*/ initial: R, /*1*/ operation: (acc: R, kotlin.Float) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.IntArray.scan(/*0*/ initial: R, /*1*/ operation: (acc: R, kotlin.Int) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.LongArray.scan(/*0*/ initial: R, /*1*/ operation: (acc: R, kotlin.Long) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.ShortArray.scan(/*0*/ initial: R, /*1*/ operation: (acc: R, kotlin.Short) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.UByteArray.scan(/*0*/ initial: R, /*1*/ operation: (acc: R, kotlin.UByte) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.UIntArray.scan(/*0*/ initial: R, /*1*/ operation: (acc: R, kotlin.UInt) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.ULongArray.scan(/*0*/ initial: R, /*1*/ operation: (acc: R, kotlin.ULong) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.UShortArray.scan(/*0*/ initial: R, /*1*/ operation: (acc: R, kotlin.UShort) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi public inline fun </*0*/ T, /*1*/ R> kotlin.collections.Iterable<T>.scan(/*0*/ initial: R, /*1*/ operation: (acc: R, T) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi public inline fun </*0*/ T, /*1*/ R> kotlin.Array<out T>.scanIndexed(/*0*/ initial: R, /*1*/ operation: (index: kotlin.Int, acc: R, T) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.BooleanArray.scanIndexed(/*0*/ initial: R, /*1*/ operation: (index: kotlin.Int, acc: R, kotlin.Boolean) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.ByteArray.scanIndexed(/*0*/ initial: R, /*1*/ operation: (index: kotlin.Int, acc: R, kotlin.Byte) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.CharArray.scanIndexed(/*0*/ initial: R, /*1*/ operation: (index: kotlin.Int, acc: R, kotlin.Char) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.DoubleArray.scanIndexed(/*0*/ initial: R, /*1*/ operation: (index: kotlin.Int, acc: R, kotlin.Double) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.FloatArray.scanIndexed(/*0*/ initial: R, /*1*/ operation: (index: kotlin.Int, acc: R, kotlin.Float) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.IntArray.scanIndexed(/*0*/ initial: R, /*1*/ operation: (index: kotlin.Int, acc: R, kotlin.Int) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.LongArray.scanIndexed(/*0*/ initial: R, /*1*/ operation: (index: kotlin.Int, acc: R, kotlin.Long) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.ShortArray.scanIndexed(/*0*/ initial: R, /*1*/ operation: (index: kotlin.Int, acc: R, kotlin.Short) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.UByteArray.scanIndexed(/*0*/ initial: R, /*1*/ operation: (index: kotlin.Int, acc: R, kotlin.UByte) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.UIntArray.scanIndexed(/*0*/ initial: R, /*1*/ operation: (index: kotlin.Int, acc: R, kotlin.UInt) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.ULongArray.scanIndexed(/*0*/ initial: R, /*1*/ operation: (index: kotlin.Int, acc: R, kotlin.ULong) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ R> kotlin.UShortArray.scanIndexed(/*0*/ initial: R, /*1*/ operation: (index: kotlin.Int, acc: R, kotlin.UShort) -> R): kotlin.collections.List<R>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi public inline fun </*0*/ T, /*1*/ R> kotlin.collections.Iterable<T>.scanIndexed(/*0*/ initial: R, /*1*/ operation: (index: kotlin.Int, acc: R, T) -> R): kotlin.collections.List<R>
@kotlin.Deprecated(message = "Use runningReduce instead.", replaceWith = kotlin.ReplaceWith(expression = "runningReduce(operation)", imports = {})) @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi public inline fun </*0*/ S, /*1*/ T : S> kotlin.Array<out T>.scanReduce(/*0*/ operation: (acc: S, T) -> S): kotlin.collections.List<S>
@kotlin.Deprecated(message = "Use runningReduce instead.", replaceWith = kotlin.ReplaceWith(expression = "runningReduce(operation)", imports = {})) @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.BooleanArray.scanReduce(/*0*/ operation: (acc: kotlin.Boolean, kotlin.Boolean) -> kotlin.Boolean): kotlin.collections.List<kotlin.Boolean>
@kotlin.Deprecated(message = "Use runningReduce instead.", replaceWith = kotlin.ReplaceWith(expression = "runningReduce(operation)", imports = {})) @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.ByteArray.scanReduce(/*0*/ operation: (acc: kotlin.Byte, kotlin.Byte) -> kotlin.Byte): kotlin.collections.List<kotlin.Byte>
@kotlin.Deprecated(message = "Use runningReduce instead.", replaceWith = kotlin.ReplaceWith(expression = "runningReduce(operation)", imports = {})) @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.CharArray.scanReduce(/*0*/ operation: (acc: kotlin.Char, kotlin.Char) -> kotlin.Char): kotlin.collections.List<kotlin.Char>
@kotlin.Deprecated(message = "Use runningReduce instead.", replaceWith = kotlin.ReplaceWith(expression = "runningReduce(operation)", imports = {})) @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.DoubleArray.scanReduce(/*0*/ operation: (acc: kotlin.Double, kotlin.Double) -> kotlin.Double): kotlin.collections.List<kotlin.Double>
@kotlin.Deprecated(message = "Use runningReduce instead.", replaceWith = kotlin.ReplaceWith(expression = "runningReduce(operation)", imports = {})) @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.FloatArray.scanReduce(/*0*/ operation: (acc: kotlin.Float, kotlin.Float) -> kotlin.Float): kotlin.collections.List<kotlin.Float>
@kotlin.Deprecated(message = "Use runningReduce instead.", replaceWith = kotlin.ReplaceWith(expression = "runningReduce(operation)", imports = {})) @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.IntArray.scanReduce(/*0*/ operation: (acc: kotlin.Int, kotlin.Int) -> kotlin.Int): kotlin.collections.List<kotlin.Int>
@kotlin.Deprecated(message = "Use runningReduce instead.", replaceWith = kotlin.ReplaceWith(expression = "runningReduce(operation)", imports = {})) @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.LongArray.scanReduce(/*0*/ operation: (acc: kotlin.Long, kotlin.Long) -> kotlin.Long): kotlin.collections.List<kotlin.Long>
@kotlin.Deprecated(message = "Use runningReduce instead.", replaceWith = kotlin.ReplaceWith(expression = "runningReduce(operation)", imports = {})) @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.ShortArray.scanReduce(/*0*/ operation: (acc: kotlin.Short, kotlin.Short) -> kotlin.Short): kotlin.collections.List<kotlin.Short>
@kotlin.Deprecated(message = "Use runningReduce instead.", replaceWith = kotlin.ReplaceWith(expression = "runningReduce(operation)", imports = {})) @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UByteArray.scanReduce(/*0*/ operation: (acc: kotlin.UByte, kotlin.UByte) -> kotlin.UByte): kotlin.collections.List<kotlin.UByte>
@kotlin.Deprecated(message = "Use runningReduce instead.", replaceWith = kotlin.ReplaceWith(expression = "runningReduce(operation)", imports = {})) @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UIntArray.scanReduce(/*0*/ operation: (acc: kotlin.UInt, kotlin.UInt) -> kotlin.UInt): kotlin.collections.List<kotlin.UInt>
@kotlin.Deprecated(message = "Use runningReduce instead.", replaceWith = kotlin.ReplaceWith(expression = "runningReduce(operation)", imports = {})) @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ULongArray.scanReduce(/*0*/ operation: (acc: kotlin.ULong, kotlin.ULong) -> kotlin.ULong): kotlin.collections.List<kotlin.ULong>
@kotlin.Deprecated(message = "Use runningReduce instead.", replaceWith = kotlin.ReplaceWith(expression = "runningReduce(operation)", imports = {})) @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UShortArray.scanReduce(/*0*/ operation: (acc: kotlin.UShort, kotlin.UShort) -> kotlin.UShort): kotlin.collections.List<kotlin.UShort>
@kotlin.Deprecated(message = "Use runningReduce instead.", replaceWith = kotlin.ReplaceWith(expression = "runningReduce(operation)", imports = {})) @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi public inline fun </*0*/ S, /*1*/ T : S> kotlin.collections.Iterable<T>.scanReduce(/*0*/ operation: (acc: S, T) -> S): kotlin.collections.List<S>
@kotlin.Deprecated(message = "Use runningReduceIndexed instead.", replaceWith = kotlin.ReplaceWith(expression = "runningReduceIndexed(operation)", imports = {})) @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi public inline fun </*0*/ S, /*1*/ T : S> kotlin.Array<out T>.scanReduceIndexed(/*0*/ operation: (index: kotlin.Int, acc: S, T) -> S): kotlin.collections.List<S>
@kotlin.Deprecated(message = "Use runningReduceIndexed instead.", replaceWith = kotlin.ReplaceWith(expression = "runningReduceIndexed(operation)", imports = {})) @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.BooleanArray.scanReduceIndexed(/*0*/ operation: (index: kotlin.Int, acc: kotlin.Boolean, kotlin.Boolean) -> kotlin.Boolean): kotlin.collections.List<kotlin.Boolean>
@kotlin.Deprecated(message = "Use runningReduceIndexed instead.", replaceWith = kotlin.ReplaceWith(expression = "runningReduceIndexed(operation)", imports = {})) @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.ByteArray.scanReduceIndexed(/*0*/ operation: (index: kotlin.Int, acc: kotlin.Byte, kotlin.Byte) -> kotlin.Byte): kotlin.collections.List<kotlin.Byte>
@kotlin.Deprecated(message = "Use runningReduceIndexed instead.", replaceWith = kotlin.ReplaceWith(expression = "runningReduceIndexed(operation)", imports = {})) @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.CharArray.scanReduceIndexed(/*0*/ operation: (index: kotlin.Int, acc: kotlin.Char, kotlin.Char) -> kotlin.Char): kotlin.collections.List<kotlin.Char>
@kotlin.Deprecated(message = "Use runningReduceIndexed instead.", replaceWith = kotlin.ReplaceWith(expression = "runningReduceIndexed(operation)", imports = {})) @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.DoubleArray.scanReduceIndexed(/*0*/ operation: (index: kotlin.Int, acc: kotlin.Double, kotlin.Double) -> kotlin.Double): kotlin.collections.List<kotlin.Double>
@kotlin.Deprecated(message = "Use runningReduceIndexed instead.", replaceWith = kotlin.ReplaceWith(expression = "runningReduceIndexed(operation)", imports = {})) @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.FloatArray.scanReduceIndexed(/*0*/ operation: (index: kotlin.Int, acc: kotlin.Float, kotlin.Float) -> kotlin.Float): kotlin.collections.List<kotlin.Float>
@kotlin.Deprecated(message = "Use runningReduceIndexed instead.", replaceWith = kotlin.ReplaceWith(expression = "runningReduceIndexed(operation)", imports = {})) @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.IntArray.scanReduceIndexed(/*0*/ operation: (index: kotlin.Int, acc: kotlin.Int, kotlin.Int) -> kotlin.Int): kotlin.collections.List<kotlin.Int>
@kotlin.Deprecated(message = "Use runningReduceIndexed instead.", replaceWith = kotlin.ReplaceWith(expression = "runningReduceIndexed(operation)", imports = {})) @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.LongArray.scanReduceIndexed(/*0*/ operation: (index: kotlin.Int, acc: kotlin.Long, kotlin.Long) -> kotlin.Long): kotlin.collections.List<kotlin.Long>
@kotlin.Deprecated(message = "Use runningReduceIndexed instead.", replaceWith = kotlin.ReplaceWith(expression = "runningReduceIndexed(operation)", imports = {})) @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.ShortArray.scanReduceIndexed(/*0*/ operation: (index: kotlin.Int, acc: kotlin.Short, kotlin.Short) -> kotlin.Short): kotlin.collections.List<kotlin.Short>
@kotlin.Deprecated(message = "Use runningReduceIndexed instead.", replaceWith = kotlin.ReplaceWith(expression = "runningReduceIndexed(operation)", imports = {})) @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UByteArray.scanReduceIndexed(/*0*/ operation: (index: kotlin.Int, acc: kotlin.UByte, kotlin.UByte) -> kotlin.UByte): kotlin.collections.List<kotlin.UByte>
@kotlin.Deprecated(message = "Use runningReduceIndexed instead.", replaceWith = kotlin.ReplaceWith(expression = "runningReduceIndexed(operation)", imports = {})) @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UIntArray.scanReduceIndexed(/*0*/ operation: (index: kotlin.Int, acc: kotlin.UInt, kotlin.UInt) -> kotlin.UInt): kotlin.collections.List<kotlin.UInt>
@kotlin.Deprecated(message = "Use runningReduceIndexed instead.", replaceWith = kotlin.ReplaceWith(expression = "runningReduceIndexed(operation)", imports = {})) @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ULongArray.scanReduceIndexed(/*0*/ operation: (index: kotlin.Int, acc: kotlin.ULong, kotlin.ULong) -> kotlin.ULong): kotlin.collections.List<kotlin.ULong>
@kotlin.Deprecated(message = "Use runningReduceIndexed instead.", replaceWith = kotlin.ReplaceWith(expression = "runningReduceIndexed(operation)", imports = {})) @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UShortArray.scanReduceIndexed(/*0*/ operation: (index: kotlin.Int, acc: kotlin.UShort, kotlin.UShort) -> kotlin.UShort): kotlin.collections.List<kotlin.UShort>
@kotlin.Deprecated(message = "Use runningReduceIndexed instead.", replaceWith = kotlin.ReplaceWith(expression = "runningReduceIndexed(operation)", imports = {})) @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi public inline fun </*0*/ S, /*1*/ T : S> kotlin.collections.Iterable<T>.scanReduceIndexed(/*0*/ operation: (index: kotlin.Int, acc: S, T) -> S): kotlin.collections.List<S>
@kotlin.internal.InlineOnly public inline operator fun </*0*/ K, /*1*/ V> kotlin.collections.MutableMap<K, V>.set(/*0*/ key: K, /*1*/ value: V): kotlin.Unit
@kotlin.internal.InlineOnly public inline operator fun </*0*/ V> kotlin.collections.MutableMap<in kotlin.String, in V>.setValue(/*0*/ thisRef: kotlin.Any?, /*1*/ property: kotlin.reflect.KProperty<*>, /*2*/ value: V): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun </*0*/ T> kotlin.Array<T>.shuffle(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun </*0*/ T> kotlin.Array<T>.shuffle(/*0*/ random: kotlin.random.Random): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.BooleanArray.shuffle(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.BooleanArray.shuffle(/*0*/ random: kotlin.random.Random): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.ByteArray.shuffle(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.ByteArray.shuffle(/*0*/ random: kotlin.random.Random): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.CharArray.shuffle(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.CharArray.shuffle(/*0*/ random: kotlin.random.Random): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.DoubleArray.shuffle(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.DoubleArray.shuffle(/*0*/ random: kotlin.random.Random): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.FloatArray.shuffle(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.FloatArray.shuffle(/*0*/ random: kotlin.random.Random): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.IntArray.shuffle(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.IntArray.shuffle(/*0*/ random: kotlin.random.Random): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.LongArray.shuffle(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.LongArray.shuffle(/*0*/ random: kotlin.random.Random): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.ShortArray.shuffle(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.ShortArray.shuffle(/*0*/ random: kotlin.random.Random): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.shuffle(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.shuffle(/*0*/ random: kotlin.random.Random): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.shuffle(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.shuffle(/*0*/ random: kotlin.random.Random): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.shuffle(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.shuffle(/*0*/ random: kotlin.random.Random): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.shuffle(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.shuffle(/*0*/ random: kotlin.random.Random): kotlin.Unit
@kotlin.SinceKotlin(version = "1.2") public fun </*0*/ T> kotlin.collections.MutableList<T>.shuffle(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.3") public fun </*0*/ T> kotlin.collections.MutableList<T>.shuffle(/*0*/ random: kotlin.random.Random): kotlin.Unit
@kotlin.SinceKotlin(version = "1.2") public fun </*0*/ T> kotlin.collections.Iterable<T>.shuffled(): kotlin.collections.List<T>
@kotlin.SinceKotlin(version = "1.3") public fun </*0*/ T> kotlin.collections.Iterable<T>.shuffled(/*0*/ random: kotlin.random.Random): kotlin.collections.List<T>
public fun </*0*/ T> kotlin.Array<out T>.single(): T
public inline fun </*0*/ T> kotlin.Array<out T>.single(/*0*/ predicate: (T) -> kotlin.Boolean): T
public fun kotlin.BooleanArray.single(): kotlin.Boolean
public inline fun kotlin.BooleanArray.single(/*0*/ predicate: (kotlin.Boolean) -> kotlin.Boolean): kotlin.Boolean
public fun kotlin.ByteArray.single(): kotlin.Byte
public inline fun kotlin.ByteArray.single(/*0*/ predicate: (kotlin.Byte) -> kotlin.Boolean): kotlin.Byte
public fun kotlin.CharArray.single(): kotlin.Char
public inline fun kotlin.CharArray.single(/*0*/ predicate: (kotlin.Char) -> kotlin.Boolean): kotlin.Char
public fun kotlin.DoubleArray.single(): kotlin.Double
public inline fun kotlin.DoubleArray.single(/*0*/ predicate: (kotlin.Double) -> kotlin.Boolean): kotlin.Double
public fun kotlin.FloatArray.single(): kotlin.Float
public inline fun kotlin.FloatArray.single(/*0*/ predicate: (kotlin.Float) -> kotlin.Boolean): kotlin.Float
public fun kotlin.IntArray.single(): kotlin.Int
public inline fun kotlin.IntArray.single(/*0*/ predicate: (kotlin.Int) -> kotlin.Boolean): kotlin.Int
public fun kotlin.LongArray.single(): kotlin.Long
public inline fun kotlin.LongArray.single(/*0*/ predicate: (kotlin.Long) -> kotlin.Boolean): kotlin.Long
public fun kotlin.ShortArray.single(): kotlin.Short
public inline fun kotlin.ShortArray.single(/*0*/ predicate: (kotlin.Short) -> kotlin.Boolean): kotlin.Short
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UByteArray.single(): kotlin.UByte
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UByteArray.single(/*0*/ predicate: (kotlin.UByte) -> kotlin.Boolean): kotlin.UByte
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UIntArray.single(): kotlin.UInt
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UIntArray.single(/*0*/ predicate: (kotlin.UInt) -> kotlin.Boolean): kotlin.UInt
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ULongArray.single(): kotlin.ULong
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ULongArray.single(/*0*/ predicate: (kotlin.ULong) -> kotlin.Boolean): kotlin.ULong
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UShortArray.single(): kotlin.UShort
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UShortArray.single(/*0*/ predicate: (kotlin.UShort) -> kotlin.Boolean): kotlin.UShort
public fun </*0*/ T> kotlin.collections.Iterable<T>.single(): T
public inline fun </*0*/ T> kotlin.collections.Iterable<T>.single(/*0*/ predicate: (T) -> kotlin.Boolean): T
public fun </*0*/ T> kotlin.collections.List<T>.single(): T
public fun </*0*/ T> kotlin.Array<out T>.singleOrNull(): T?
public inline fun </*0*/ T> kotlin.Array<out T>.singleOrNull(/*0*/ predicate: (T) -> kotlin.Boolean): T?
public fun kotlin.BooleanArray.singleOrNull(): kotlin.Boolean?
public inline fun kotlin.BooleanArray.singleOrNull(/*0*/ predicate: (kotlin.Boolean) -> kotlin.Boolean): kotlin.Boolean?
public fun kotlin.ByteArray.singleOrNull(): kotlin.Byte?
public inline fun kotlin.ByteArray.singleOrNull(/*0*/ predicate: (kotlin.Byte) -> kotlin.Boolean): kotlin.Byte?
public fun kotlin.CharArray.singleOrNull(): kotlin.Char?
public inline fun kotlin.CharArray.singleOrNull(/*0*/ predicate: (kotlin.Char) -> kotlin.Boolean): kotlin.Char?
public fun kotlin.DoubleArray.singleOrNull(): kotlin.Double?
public inline fun kotlin.DoubleArray.singleOrNull(/*0*/ predicate: (kotlin.Double) -> kotlin.Boolean): kotlin.Double?
public fun kotlin.FloatArray.singleOrNull(): kotlin.Float?
public inline fun kotlin.FloatArray.singleOrNull(/*0*/ predicate: (kotlin.Float) -> kotlin.Boolean): kotlin.Float?
public fun kotlin.IntArray.singleOrNull(): kotlin.Int?
public inline fun kotlin.IntArray.singleOrNull(/*0*/ predicate: (kotlin.Int) -> kotlin.Boolean): kotlin.Int?
public fun kotlin.LongArray.singleOrNull(): kotlin.Long?
public inline fun kotlin.LongArray.singleOrNull(/*0*/ predicate: (kotlin.Long) -> kotlin.Boolean): kotlin.Long?
public fun kotlin.ShortArray.singleOrNull(): kotlin.Short?
public inline fun kotlin.ShortArray.singleOrNull(/*0*/ predicate: (kotlin.Short) -> kotlin.Boolean): kotlin.Short?
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.singleOrNull(): kotlin.UByte?
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UByteArray.singleOrNull(/*0*/ predicate: (kotlin.UByte) -> kotlin.Boolean): kotlin.UByte?
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.singleOrNull(): kotlin.UInt?
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UIntArray.singleOrNull(/*0*/ predicate: (kotlin.UInt) -> kotlin.Boolean): kotlin.UInt?
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.singleOrNull(): kotlin.ULong?
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ULongArray.singleOrNull(/*0*/ predicate: (kotlin.ULong) -> kotlin.Boolean): kotlin.ULong?
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.singleOrNull(): kotlin.UShort?
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UShortArray.singleOrNull(/*0*/ predicate: (kotlin.UShort) -> kotlin.Boolean): kotlin.UShort?
public fun </*0*/ T> kotlin.collections.Iterable<T>.singleOrNull(): T?
public inline fun </*0*/ T> kotlin.collections.Iterable<T>.singleOrNull(/*0*/ predicate: (T) -> kotlin.Boolean): T?
public fun </*0*/ T> kotlin.collections.List<T>.singleOrNull(): T?
public fun </*0*/ T> kotlin.Array<out T>.slice(/*0*/ indices: kotlin.collections.Iterable<kotlin.Int>): kotlin.collections.List<T>
public fun </*0*/ T> kotlin.Array<out T>.slice(/*0*/ indices: kotlin.ranges.IntRange): kotlin.collections.List<T>
public fun kotlin.BooleanArray.slice(/*0*/ indices: kotlin.collections.Iterable<kotlin.Int>): kotlin.collections.List<kotlin.Boolean>
public fun kotlin.BooleanArray.slice(/*0*/ indices: kotlin.ranges.IntRange): kotlin.collections.List<kotlin.Boolean>
public fun kotlin.ByteArray.slice(/*0*/ indices: kotlin.collections.Iterable<kotlin.Int>): kotlin.collections.List<kotlin.Byte>
public fun kotlin.ByteArray.slice(/*0*/ indices: kotlin.ranges.IntRange): kotlin.collections.List<kotlin.Byte>
public fun kotlin.CharArray.slice(/*0*/ indices: kotlin.collections.Iterable<kotlin.Int>): kotlin.collections.List<kotlin.Char>
public fun kotlin.CharArray.slice(/*0*/ indices: kotlin.ranges.IntRange): kotlin.collections.List<kotlin.Char>
public fun kotlin.DoubleArray.slice(/*0*/ indices: kotlin.collections.Iterable<kotlin.Int>): kotlin.collections.List<kotlin.Double>
public fun kotlin.DoubleArray.slice(/*0*/ indices: kotlin.ranges.IntRange): kotlin.collections.List<kotlin.Double>
public fun kotlin.FloatArray.slice(/*0*/ indices: kotlin.collections.Iterable<kotlin.Int>): kotlin.collections.List<kotlin.Float>
public fun kotlin.FloatArray.slice(/*0*/ indices: kotlin.ranges.IntRange): kotlin.collections.List<kotlin.Float>
public fun kotlin.IntArray.slice(/*0*/ indices: kotlin.collections.Iterable<kotlin.Int>): kotlin.collections.List<kotlin.Int>
public fun kotlin.IntArray.slice(/*0*/ indices: kotlin.ranges.IntRange): kotlin.collections.List<kotlin.Int>
public fun kotlin.LongArray.slice(/*0*/ indices: kotlin.collections.Iterable<kotlin.Int>): kotlin.collections.List<kotlin.Long>
public fun kotlin.LongArray.slice(/*0*/ indices: kotlin.ranges.IntRange): kotlin.collections.List<kotlin.Long>
public fun kotlin.ShortArray.slice(/*0*/ indices: kotlin.collections.Iterable<kotlin.Int>): kotlin.collections.List<kotlin.Short>
public fun kotlin.ShortArray.slice(/*0*/ indices: kotlin.ranges.IntRange): kotlin.collections.List<kotlin.Short>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.slice(/*0*/ indices: kotlin.collections.Iterable<kotlin.Int>): kotlin.collections.List<kotlin.UByte>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.slice(/*0*/ indices: kotlin.ranges.IntRange): kotlin.collections.List<kotlin.UByte>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.slice(/*0*/ indices: kotlin.collections.Iterable<kotlin.Int>): kotlin.collections.List<kotlin.UInt>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.slice(/*0*/ indices: kotlin.ranges.IntRange): kotlin.collections.List<kotlin.UInt>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.slice(/*0*/ indices: kotlin.collections.Iterable<kotlin.Int>): kotlin.collections.List<kotlin.ULong>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.slice(/*0*/ indices: kotlin.ranges.IntRange): kotlin.collections.List<kotlin.ULong>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.slice(/*0*/ indices: kotlin.collections.Iterable<kotlin.Int>): kotlin.collections.List<kotlin.UShort>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.slice(/*0*/ indices: kotlin.ranges.IntRange): kotlin.collections.List<kotlin.UShort>
public fun </*0*/ T> kotlin.collections.List<T>.slice(/*0*/ indices: kotlin.collections.Iterable<kotlin.Int>): kotlin.collections.List<T>
public fun </*0*/ T> kotlin.collections.List<T>.slice(/*0*/ indices: kotlin.ranges.IntRange): kotlin.collections.List<T>
public fun </*0*/ T> kotlin.Array<T>.sliceArray(/*0*/ indices: kotlin.collections.Collection<kotlin.Int>): kotlin.Array<T>
public fun </*0*/ T> kotlin.Array<T>.sliceArray(/*0*/ indices: kotlin.ranges.IntRange): kotlin.Array<T>
public fun kotlin.BooleanArray.sliceArray(/*0*/ indices: kotlin.collections.Collection<kotlin.Int>): kotlin.BooleanArray
public fun kotlin.BooleanArray.sliceArray(/*0*/ indices: kotlin.ranges.IntRange): kotlin.BooleanArray
public fun kotlin.ByteArray.sliceArray(/*0*/ indices: kotlin.collections.Collection<kotlin.Int>): kotlin.ByteArray
public fun kotlin.ByteArray.sliceArray(/*0*/ indices: kotlin.ranges.IntRange): kotlin.ByteArray
public fun kotlin.CharArray.sliceArray(/*0*/ indices: kotlin.collections.Collection<kotlin.Int>): kotlin.CharArray
public fun kotlin.CharArray.sliceArray(/*0*/ indices: kotlin.ranges.IntRange): kotlin.CharArray
public fun kotlin.DoubleArray.sliceArray(/*0*/ indices: kotlin.collections.Collection<kotlin.Int>): kotlin.DoubleArray
public fun kotlin.DoubleArray.sliceArray(/*0*/ indices: kotlin.ranges.IntRange): kotlin.DoubleArray
public fun kotlin.FloatArray.sliceArray(/*0*/ indices: kotlin.collections.Collection<kotlin.Int>): kotlin.FloatArray
public fun kotlin.FloatArray.sliceArray(/*0*/ indices: kotlin.ranges.IntRange): kotlin.FloatArray
public fun kotlin.IntArray.sliceArray(/*0*/ indices: kotlin.collections.Collection<kotlin.Int>): kotlin.IntArray
public fun kotlin.IntArray.sliceArray(/*0*/ indices: kotlin.ranges.IntRange): kotlin.IntArray
public fun kotlin.LongArray.sliceArray(/*0*/ indices: kotlin.collections.Collection<kotlin.Int>): kotlin.LongArray
public fun kotlin.LongArray.sliceArray(/*0*/ indices: kotlin.ranges.IntRange): kotlin.LongArray
public fun kotlin.ShortArray.sliceArray(/*0*/ indices: kotlin.collections.Collection<kotlin.Int>): kotlin.ShortArray
public fun kotlin.ShortArray.sliceArray(/*0*/ indices: kotlin.ranges.IntRange): kotlin.ShortArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.sliceArray(/*0*/ indices: kotlin.collections.Collection<kotlin.Int>): kotlin.UByteArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.sliceArray(/*0*/ indices: kotlin.ranges.IntRange): kotlin.UByteArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.sliceArray(/*0*/ indices: kotlin.collections.Collection<kotlin.Int>): kotlin.UIntArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.sliceArray(/*0*/ indices: kotlin.ranges.IntRange): kotlin.UIntArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.sliceArray(/*0*/ indices: kotlin.collections.Collection<kotlin.Int>): kotlin.ULongArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.sliceArray(/*0*/ indices: kotlin.ranges.IntRange): kotlin.ULongArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.sliceArray(/*0*/ indices: kotlin.collections.Collection<kotlin.Int>): kotlin.UShortArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.sliceArray(/*0*/ indices: kotlin.ranges.IntRange): kotlin.UShortArray
public fun </*0*/ T : kotlin.Comparable<T>> kotlin.Array<out T>.sort(): kotlin.Unit
public fun </*0*/ T> kotlin.Array<out T>.sort(/*0*/ comparison: (a: T, b: T) -> kotlin.Int): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun </*0*/ T : kotlin.Comparable<T>> kotlin.Array<out T>.sort(/*0*/ fromIndex: kotlin.Int = ..., /*1*/ toIndex: kotlin.Int = ...): kotlin.Unit
@kotlin.js.library(name = "primitiveArraySort") public fun kotlin.ByteArray.sort(): kotlin.Unit
@kotlin.internal.InlineOnly public inline fun kotlin.ByteArray.sort(/*0*/ noinline comparison: (a: kotlin.Byte, b: kotlin.Byte) -> kotlin.Int): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.ByteArray.sort(/*0*/ fromIndex: kotlin.Int = ..., /*1*/ toIndex: kotlin.Int = ...): kotlin.Unit
@kotlin.js.library(name = "primitiveArraySort") public fun kotlin.CharArray.sort(): kotlin.Unit
@kotlin.internal.InlineOnly public inline fun kotlin.CharArray.sort(/*0*/ noinline comparison: (a: kotlin.Char, b: kotlin.Char) -> kotlin.Int): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.CharArray.sort(/*0*/ fromIndex: kotlin.Int = ..., /*1*/ toIndex: kotlin.Int = ...): kotlin.Unit
@kotlin.js.library(name = "primitiveArraySort") public fun kotlin.DoubleArray.sort(): kotlin.Unit
@kotlin.internal.InlineOnly public inline fun kotlin.DoubleArray.sort(/*0*/ noinline comparison: (a: kotlin.Double, b: kotlin.Double) -> kotlin.Int): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.DoubleArray.sort(/*0*/ fromIndex: kotlin.Int = ..., /*1*/ toIndex: kotlin.Int = ...): kotlin.Unit
@kotlin.js.library(name = "primitiveArraySort") public fun kotlin.FloatArray.sort(): kotlin.Unit
@kotlin.internal.InlineOnly public inline fun kotlin.FloatArray.sort(/*0*/ noinline comparison: (a: kotlin.Float, b: kotlin.Float) -> kotlin.Int): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.FloatArray.sort(/*0*/ fromIndex: kotlin.Int = ..., /*1*/ toIndex: kotlin.Int = ...): kotlin.Unit
@kotlin.js.library(name = "primitiveArraySort") public fun kotlin.IntArray.sort(): kotlin.Unit
@kotlin.internal.InlineOnly public inline fun kotlin.IntArray.sort(/*0*/ noinline comparison: (a: kotlin.Int, b: kotlin.Int) -> kotlin.Int): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.IntArray.sort(/*0*/ fromIndex: kotlin.Int = ..., /*1*/ toIndex: kotlin.Int = ...): kotlin.Unit
public fun kotlin.LongArray.sort(): kotlin.Unit
@kotlin.internal.InlineOnly public inline fun kotlin.LongArray.sort(/*0*/ noinline comparison: (a: kotlin.Long, b: kotlin.Long) -> kotlin.Int): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.LongArray.sort(/*0*/ fromIndex: kotlin.Int = ..., /*1*/ toIndex: kotlin.Int = ...): kotlin.Unit
@kotlin.js.library(name = "primitiveArraySort") public fun kotlin.ShortArray.sort(): kotlin.Unit
@kotlin.internal.InlineOnly public inline fun kotlin.ShortArray.sort(/*0*/ noinline comparison: (a: kotlin.Short, b: kotlin.Short) -> kotlin.Int): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.ShortArray.sort(/*0*/ fromIndex: kotlin.Int = ..., /*1*/ toIndex: kotlin.Int = ...): kotlin.Unit
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.sort(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.sort(/*0*/ fromIndex: kotlin.Int = ..., /*1*/ toIndex: kotlin.Int = ...): kotlin.Unit
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.sort(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.sort(/*0*/ fromIndex: kotlin.Int = ..., /*1*/ toIndex: kotlin.Int = ...): kotlin.Unit
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.sort(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.sort(/*0*/ fromIndex: kotlin.Int = ..., /*1*/ toIndex: kotlin.Int = ...): kotlin.Unit
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.sort(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.sort(/*0*/ fromIndex: kotlin.Int = ..., /*1*/ toIndex: kotlin.Int = ...): kotlin.Unit
public fun </*0*/ T : kotlin.Comparable<T>> kotlin.collections.MutableList<T>.sort(): kotlin.Unit
public inline fun </*0*/ T, /*1*/ R : kotlin.Comparable<R>> kotlin.Array<out T>.sortBy(/*0*/ crossinline selector: (T) -> R?): kotlin.Unit
public inline fun </*0*/ T, /*1*/ R : kotlin.Comparable<R>> kotlin.collections.MutableList<T>.sortBy(/*0*/ crossinline selector: (T) -> R?): kotlin.Unit
public inline fun </*0*/ T, /*1*/ R : kotlin.Comparable<R>> kotlin.Array<out T>.sortByDescending(/*0*/ crossinline selector: (T) -> R?): kotlin.Unit
public inline fun </*0*/ T, /*1*/ R : kotlin.Comparable<R>> kotlin.collections.MutableList<T>.sortByDescending(/*0*/ crossinline selector: (T) -> R?): kotlin.Unit
public fun </*0*/ T : kotlin.Comparable<T>> kotlin.Array<out T>.sortDescending(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun </*0*/ T : kotlin.Comparable<T>> kotlin.Array<out T>.sortDescending(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
public fun kotlin.ByteArray.sortDescending(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.ByteArray.sortDescending(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
public fun kotlin.CharArray.sortDescending(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.CharArray.sortDescending(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
public fun kotlin.DoubleArray.sortDescending(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.DoubleArray.sortDescending(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
public fun kotlin.FloatArray.sortDescending(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.FloatArray.sortDescending(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
public fun kotlin.IntArray.sortDescending(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.IntArray.sortDescending(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
public fun kotlin.LongArray.sortDescending(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.LongArray.sortDescending(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
public fun kotlin.ShortArray.sortDescending(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.ShortArray.sortDescending(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.sortDescending(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.sortDescending(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.sortDescending(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.sortDescending(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.sortDescending(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.sortDescending(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.sortDescending(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.sortDescending(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
public fun </*0*/ T : kotlin.Comparable<T>> kotlin.collections.MutableList<T>.sortDescending(): kotlin.Unit
public fun </*0*/ T> kotlin.Array<out T>.sortWith(/*0*/ comparator: kotlin.Comparator<in T>): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun </*0*/ T> kotlin.Array<out T>.sortWith(/*0*/ comparator: kotlin.Comparator<in T>, /*1*/ fromIndex: kotlin.Int = ..., /*2*/ toIndex: kotlin.Int = ...): kotlin.Unit
public fun </*0*/ T> kotlin.collections.MutableList<T>.sortWith(/*0*/ comparator: kotlin.Comparator<in T>): kotlin.Unit
public fun </*0*/ T : kotlin.Comparable<T>> kotlin.Array<out T>.sorted(): kotlin.collections.List<T>
public fun kotlin.ByteArray.sorted(): kotlin.collections.List<kotlin.Byte>
public fun kotlin.CharArray.sorted(): kotlin.collections.List<kotlin.Char>
public fun kotlin.DoubleArray.sorted(): kotlin.collections.List<kotlin.Double>
public fun kotlin.FloatArray.sorted(): kotlin.collections.List<kotlin.Float>
public fun kotlin.IntArray.sorted(): kotlin.collections.List<kotlin.Int>
public fun kotlin.LongArray.sorted(): kotlin.collections.List<kotlin.Long>
public fun kotlin.ShortArray.sorted(): kotlin.collections.List<kotlin.Short>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.sorted(): kotlin.collections.List<kotlin.UByte>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.sorted(): kotlin.collections.List<kotlin.UInt>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.sorted(): kotlin.collections.List<kotlin.ULong>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.sorted(): kotlin.collections.List<kotlin.UShort>
public fun </*0*/ T : kotlin.Comparable<T>> kotlin.collections.Iterable<T>.sorted(): kotlin.collections.List<T>
public fun </*0*/ T : kotlin.Comparable<T>> kotlin.Array<T>.sortedArray(): kotlin.Array<T>
public fun kotlin.ByteArray.sortedArray(): kotlin.ByteArray
public fun kotlin.CharArray.sortedArray(): kotlin.CharArray
public fun kotlin.DoubleArray.sortedArray(): kotlin.DoubleArray
public fun kotlin.FloatArray.sortedArray(): kotlin.FloatArray
public fun kotlin.IntArray.sortedArray(): kotlin.IntArray
public fun kotlin.LongArray.sortedArray(): kotlin.LongArray
public fun kotlin.ShortArray.sortedArray(): kotlin.ShortArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.sortedArray(): kotlin.UByteArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.sortedArray(): kotlin.UIntArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.sortedArray(): kotlin.ULongArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.sortedArray(): kotlin.UShortArray
public fun </*0*/ T : kotlin.Comparable<T>> kotlin.Array<T>.sortedArrayDescending(): kotlin.Array<T>
public fun kotlin.ByteArray.sortedArrayDescending(): kotlin.ByteArray
public fun kotlin.CharArray.sortedArrayDescending(): kotlin.CharArray
public fun kotlin.DoubleArray.sortedArrayDescending(): kotlin.DoubleArray
public fun kotlin.FloatArray.sortedArrayDescending(): kotlin.FloatArray
public fun kotlin.IntArray.sortedArrayDescending(): kotlin.IntArray
public fun kotlin.LongArray.sortedArrayDescending(): kotlin.LongArray
public fun kotlin.ShortArray.sortedArrayDescending(): kotlin.ShortArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.sortedArrayDescending(): kotlin.UByteArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.sortedArrayDescending(): kotlin.UIntArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.sortedArrayDescending(): kotlin.ULongArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.sortedArrayDescending(): kotlin.UShortArray
public fun </*0*/ T> kotlin.Array<out T>.sortedArrayWith(/*0*/ comparator: kotlin.Comparator<in T>): kotlin.Array<out T>
public inline fun </*0*/ T, /*1*/ R : kotlin.Comparable<R>> kotlin.Array<out T>.sortedBy(/*0*/ crossinline selector: (T) -> R?): kotlin.collections.List<T>
public inline fun </*0*/ R : kotlin.Comparable<R>> kotlin.BooleanArray.sortedBy(/*0*/ crossinline selector: (kotlin.Boolean) -> R?): kotlin.collections.List<kotlin.Boolean>
public inline fun </*0*/ R : kotlin.Comparable<R>> kotlin.ByteArray.sortedBy(/*0*/ crossinline selector: (kotlin.Byte) -> R?): kotlin.collections.List<kotlin.Byte>
public inline fun </*0*/ R : kotlin.Comparable<R>> kotlin.CharArray.sortedBy(/*0*/ crossinline selector: (kotlin.Char) -> R?): kotlin.collections.List<kotlin.Char>
public inline fun </*0*/ R : kotlin.Comparable<R>> kotlin.DoubleArray.sortedBy(/*0*/ crossinline selector: (kotlin.Double) -> R?): kotlin.collections.List<kotlin.Double>
public inline fun </*0*/ R : kotlin.Comparable<R>> kotlin.FloatArray.sortedBy(/*0*/ crossinline selector: (kotlin.Float) -> R?): kotlin.collections.List<kotlin.Float>
public inline fun </*0*/ R : kotlin.Comparable<R>> kotlin.IntArray.sortedBy(/*0*/ crossinline selector: (kotlin.Int) -> R?): kotlin.collections.List<kotlin.Int>
public inline fun </*0*/ R : kotlin.Comparable<R>> kotlin.LongArray.sortedBy(/*0*/ crossinline selector: (kotlin.Long) -> R?): kotlin.collections.List<kotlin.Long>
public inline fun </*0*/ R : kotlin.Comparable<R>> kotlin.ShortArray.sortedBy(/*0*/ crossinline selector: (kotlin.Short) -> R?): kotlin.collections.List<kotlin.Short>
public inline fun </*0*/ T, /*1*/ R : kotlin.Comparable<R>> kotlin.collections.Iterable<T>.sortedBy(/*0*/ crossinline selector: (T) -> R?): kotlin.collections.List<T>
public inline fun </*0*/ T, /*1*/ R : kotlin.Comparable<R>> kotlin.Array<out T>.sortedByDescending(/*0*/ crossinline selector: (T) -> R?): kotlin.collections.List<T>
public inline fun </*0*/ R : kotlin.Comparable<R>> kotlin.BooleanArray.sortedByDescending(/*0*/ crossinline selector: (kotlin.Boolean) -> R?): kotlin.collections.List<kotlin.Boolean>
public inline fun </*0*/ R : kotlin.Comparable<R>> kotlin.ByteArray.sortedByDescending(/*0*/ crossinline selector: (kotlin.Byte) -> R?): kotlin.collections.List<kotlin.Byte>
public inline fun </*0*/ R : kotlin.Comparable<R>> kotlin.CharArray.sortedByDescending(/*0*/ crossinline selector: (kotlin.Char) -> R?): kotlin.collections.List<kotlin.Char>
public inline fun </*0*/ R : kotlin.Comparable<R>> kotlin.DoubleArray.sortedByDescending(/*0*/ crossinline selector: (kotlin.Double) -> R?): kotlin.collections.List<kotlin.Double>
public inline fun </*0*/ R : kotlin.Comparable<R>> kotlin.FloatArray.sortedByDescending(/*0*/ crossinline selector: (kotlin.Float) -> R?): kotlin.collections.List<kotlin.Float>
public inline fun </*0*/ R : kotlin.Comparable<R>> kotlin.IntArray.sortedByDescending(/*0*/ crossinline selector: (kotlin.Int) -> R?): kotlin.collections.List<kotlin.Int>
public inline fun </*0*/ R : kotlin.Comparable<R>> kotlin.LongArray.sortedByDescending(/*0*/ crossinline selector: (kotlin.Long) -> R?): kotlin.collections.List<kotlin.Long>
public inline fun </*0*/ R : kotlin.Comparable<R>> kotlin.ShortArray.sortedByDescending(/*0*/ crossinline selector: (kotlin.Short) -> R?): kotlin.collections.List<kotlin.Short>
public inline fun </*0*/ T, /*1*/ R : kotlin.Comparable<R>> kotlin.collections.Iterable<T>.sortedByDescending(/*0*/ crossinline selector: (T) -> R?): kotlin.collections.List<T>
public fun </*0*/ T : kotlin.Comparable<T>> kotlin.Array<out T>.sortedDescending(): kotlin.collections.List<T>
public fun kotlin.ByteArray.sortedDescending(): kotlin.collections.List<kotlin.Byte>
public fun kotlin.CharArray.sortedDescending(): kotlin.collections.List<kotlin.Char>
public fun kotlin.DoubleArray.sortedDescending(): kotlin.collections.List<kotlin.Double>
public fun kotlin.FloatArray.sortedDescending(): kotlin.collections.List<kotlin.Float>
public fun kotlin.IntArray.sortedDescending(): kotlin.collections.List<kotlin.Int>
public fun kotlin.LongArray.sortedDescending(): kotlin.collections.List<kotlin.Long>
public fun kotlin.ShortArray.sortedDescending(): kotlin.collections.List<kotlin.Short>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.sortedDescending(): kotlin.collections.List<kotlin.UByte>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.sortedDescending(): kotlin.collections.List<kotlin.UInt>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.sortedDescending(): kotlin.collections.List<kotlin.ULong>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.sortedDescending(): kotlin.collections.List<kotlin.UShort>
public fun </*0*/ T : kotlin.Comparable<T>> kotlin.collections.Iterable<T>.sortedDescending(): kotlin.collections.List<T>
public fun </*0*/ T> kotlin.Array<out T>.sortedWith(/*0*/ comparator: kotlin.Comparator<in T>): kotlin.collections.List<T>
public fun kotlin.BooleanArray.sortedWith(/*0*/ comparator: kotlin.Comparator<in kotlin.Boolean>): kotlin.collections.List<kotlin.Boolean>
public fun kotlin.ByteArray.sortedWith(/*0*/ comparator: kotlin.Comparator<in kotlin.Byte>): kotlin.collections.List<kotlin.Byte>
public fun kotlin.CharArray.sortedWith(/*0*/ comparator: kotlin.Comparator<in kotlin.Char>): kotlin.collections.List<kotlin.Char>
public fun kotlin.DoubleArray.sortedWith(/*0*/ comparator: kotlin.Comparator<in kotlin.Double>): kotlin.collections.List<kotlin.Double>
public fun kotlin.FloatArray.sortedWith(/*0*/ comparator: kotlin.Comparator<in kotlin.Float>): kotlin.collections.List<kotlin.Float>
public fun kotlin.IntArray.sortedWith(/*0*/ comparator: kotlin.Comparator<in kotlin.Int>): kotlin.collections.List<kotlin.Int>
public fun kotlin.LongArray.sortedWith(/*0*/ comparator: kotlin.Comparator<in kotlin.Long>): kotlin.collections.List<kotlin.Long>
public fun kotlin.ShortArray.sortedWith(/*0*/ comparator: kotlin.Comparator<in kotlin.Short>): kotlin.collections.List<kotlin.Short>
public fun </*0*/ T> kotlin.collections.Iterable<T>.sortedWith(/*0*/ comparator: kotlin.Comparator<in T>): kotlin.collections.List<T>
public infix fun </*0*/ T> kotlin.Array<out T>.subtract(/*0*/ other: kotlin.collections.Iterable<T>): kotlin.collections.Set<T>
public infix fun kotlin.BooleanArray.subtract(/*0*/ other: kotlin.collections.Iterable<kotlin.Boolean>): kotlin.collections.Set<kotlin.Boolean>
public infix fun kotlin.ByteArray.subtract(/*0*/ other: kotlin.collections.Iterable<kotlin.Byte>): kotlin.collections.Set<kotlin.Byte>
public infix fun kotlin.CharArray.subtract(/*0*/ other: kotlin.collections.Iterable<kotlin.Char>): kotlin.collections.Set<kotlin.Char>
public infix fun kotlin.DoubleArray.subtract(/*0*/ other: kotlin.collections.Iterable<kotlin.Double>): kotlin.collections.Set<kotlin.Double>
public infix fun kotlin.FloatArray.subtract(/*0*/ other: kotlin.collections.Iterable<kotlin.Float>): kotlin.collections.Set<kotlin.Float>
public infix fun kotlin.IntArray.subtract(/*0*/ other: kotlin.collections.Iterable<kotlin.Int>): kotlin.collections.Set<kotlin.Int>
public infix fun kotlin.LongArray.subtract(/*0*/ other: kotlin.collections.Iterable<kotlin.Long>): kotlin.collections.Set<kotlin.Long>
public infix fun kotlin.ShortArray.subtract(/*0*/ other: kotlin.collections.Iterable<kotlin.Short>): kotlin.collections.Set<kotlin.Short>
public infix fun </*0*/ T> kotlin.collections.Iterable<T>.subtract(/*0*/ other: kotlin.collections.Iterable<T>): kotlin.collections.Set<T>
@kotlin.jvm.JvmName(name = "sumOfByte") public fun kotlin.Array<out kotlin.Byte>.sum(): kotlin.Int
@kotlin.jvm.JvmName(name = "sumOfDouble") public fun kotlin.Array<out kotlin.Double>.sum(): kotlin.Double
@kotlin.jvm.JvmName(name = "sumOfFloat") public fun kotlin.Array<out kotlin.Float>.sum(): kotlin.Float
@kotlin.jvm.JvmName(name = "sumOfInt") public fun kotlin.Array<out kotlin.Int>.sum(): kotlin.Int
@kotlin.jvm.JvmName(name = "sumOfLong") public fun kotlin.Array<out kotlin.Long>.sum(): kotlin.Long
@kotlin.jvm.JvmName(name = "sumOfShort") public fun kotlin.Array<out kotlin.Short>.sum(): kotlin.Int
@kotlin.jvm.JvmName(name = "sumOfUByte") @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.Array<out kotlin.UByte>.sum(): kotlin.UInt
@kotlin.jvm.JvmName(name = "sumOfUInt") @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.Array<out kotlin.UInt>.sum(): kotlin.UInt
@kotlin.jvm.JvmName(name = "sumOfULong") @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.Array<out kotlin.ULong>.sum(): kotlin.ULong
@kotlin.jvm.JvmName(name = "sumOfUShort") @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.Array<out kotlin.UShort>.sum(): kotlin.UInt
public fun kotlin.ByteArray.sum(): kotlin.Int
public fun kotlin.DoubleArray.sum(): kotlin.Double
public fun kotlin.FloatArray.sum(): kotlin.Float
public fun kotlin.IntArray.sum(): kotlin.Int
public fun kotlin.LongArray.sum(): kotlin.Long
public fun kotlin.ShortArray.sum(): kotlin.Int
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UByteArray.sum(): kotlin.UInt
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UIntArray.sum(): kotlin.UInt
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ULongArray.sum(): kotlin.ULong
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UShortArray.sum(): kotlin.UInt
@kotlin.jvm.JvmName(name = "sumOfByte") public fun kotlin.collections.Iterable<kotlin.Byte>.sum(): kotlin.Int
@kotlin.jvm.JvmName(name = "sumOfDouble") public fun kotlin.collections.Iterable<kotlin.Double>.sum(): kotlin.Double
@kotlin.jvm.JvmName(name = "sumOfFloat") public fun kotlin.collections.Iterable<kotlin.Float>.sum(): kotlin.Float
@kotlin.jvm.JvmName(name = "sumOfInt") public fun kotlin.collections.Iterable<kotlin.Int>.sum(): kotlin.Int
@kotlin.jvm.JvmName(name = "sumOfLong") public fun kotlin.collections.Iterable<kotlin.Long>.sum(): kotlin.Long
@kotlin.jvm.JvmName(name = "sumOfShort") public fun kotlin.collections.Iterable<kotlin.Short>.sum(): kotlin.Int
@kotlin.jvm.JvmName(name = "sumOfUByte") @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.collections.Iterable<kotlin.UByte>.sum(): kotlin.UInt
@kotlin.jvm.JvmName(name = "sumOfUInt") @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.collections.Iterable<kotlin.UInt>.sum(): kotlin.UInt
@kotlin.jvm.JvmName(name = "sumOfULong") @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.collections.Iterable<kotlin.ULong>.sum(): kotlin.ULong
@kotlin.jvm.JvmName(name = "sumOfUShort") @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.collections.Iterable<kotlin.UShort>.sum(): kotlin.UInt
public inline fun </*0*/ T> kotlin.Array<out T>.sumBy(/*0*/ selector: (T) -> kotlin.Int): kotlin.Int
public inline fun kotlin.BooleanArray.sumBy(/*0*/ selector: (kotlin.Boolean) -> kotlin.Int): kotlin.Int
public inline fun kotlin.ByteArray.sumBy(/*0*/ selector: (kotlin.Byte) -> kotlin.Int): kotlin.Int
public inline fun kotlin.CharArray.sumBy(/*0*/ selector: (kotlin.Char) -> kotlin.Int): kotlin.Int
public inline fun kotlin.DoubleArray.sumBy(/*0*/ selector: (kotlin.Double) -> kotlin.Int): kotlin.Int
public inline fun kotlin.FloatArray.sumBy(/*0*/ selector: (kotlin.Float) -> kotlin.Int): kotlin.Int
public inline fun kotlin.IntArray.sumBy(/*0*/ selector: (kotlin.Int) -> kotlin.Int): kotlin.Int
public inline fun kotlin.LongArray.sumBy(/*0*/ selector: (kotlin.Long) -> kotlin.Int): kotlin.Int
public inline fun kotlin.ShortArray.sumBy(/*0*/ selector: (kotlin.Short) -> kotlin.Int): kotlin.Int
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UByteArray.sumBy(/*0*/ selector: (kotlin.UByte) -> kotlin.UInt): kotlin.UInt
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UIntArray.sumBy(/*0*/ selector: (kotlin.UInt) -> kotlin.UInt): kotlin.UInt
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ULongArray.sumBy(/*0*/ selector: (kotlin.ULong) -> kotlin.UInt): kotlin.UInt
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UShortArray.sumBy(/*0*/ selector: (kotlin.UShort) -> kotlin.UInt): kotlin.UInt
public inline fun </*0*/ T> kotlin.collections.Iterable<T>.sumBy(/*0*/ selector: (T) -> kotlin.Int): kotlin.Int
public inline fun </*0*/ T> kotlin.Array<out T>.sumByDouble(/*0*/ selector: (T) -> kotlin.Double): kotlin.Double
public inline fun kotlin.BooleanArray.sumByDouble(/*0*/ selector: (kotlin.Boolean) -> kotlin.Double): kotlin.Double
public inline fun kotlin.ByteArray.sumByDouble(/*0*/ selector: (kotlin.Byte) -> kotlin.Double): kotlin.Double
public inline fun kotlin.CharArray.sumByDouble(/*0*/ selector: (kotlin.Char) -> kotlin.Double): kotlin.Double
public inline fun kotlin.DoubleArray.sumByDouble(/*0*/ selector: (kotlin.Double) -> kotlin.Double): kotlin.Double
public inline fun kotlin.FloatArray.sumByDouble(/*0*/ selector: (kotlin.Float) -> kotlin.Double): kotlin.Double
public inline fun kotlin.IntArray.sumByDouble(/*0*/ selector: (kotlin.Int) -> kotlin.Double): kotlin.Double
public inline fun kotlin.LongArray.sumByDouble(/*0*/ selector: (kotlin.Long) -> kotlin.Double): kotlin.Double
public inline fun kotlin.ShortArray.sumByDouble(/*0*/ selector: (kotlin.Short) -> kotlin.Double): kotlin.Double
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UByteArray.sumByDouble(/*0*/ selector: (kotlin.UByte) -> kotlin.Double): kotlin.Double
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UIntArray.sumByDouble(/*0*/ selector: (kotlin.UInt) -> kotlin.Double): kotlin.Double
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ULongArray.sumByDouble(/*0*/ selector: (kotlin.ULong) -> kotlin.Double): kotlin.Double
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UShortArray.sumByDouble(/*0*/ selector: (kotlin.UShort) -> kotlin.Double): kotlin.Double
public inline fun </*0*/ T> kotlin.collections.Iterable<T>.sumByDouble(/*0*/ selector: (T) -> kotlin.Double): kotlin.Double
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfDouble") @kotlin.internal.InlineOnly public inline fun </*0*/ T> kotlin.Array<out T>.sumOf(/*0*/ selector: (T) -> kotlin.Double): kotlin.Double
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfInt") @kotlin.internal.InlineOnly public inline fun </*0*/ T> kotlin.Array<out T>.sumOf(/*0*/ selector: (T) -> kotlin.Int): kotlin.Int
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfLong") @kotlin.internal.InlineOnly public inline fun </*0*/ T> kotlin.Array<out T>.sumOf(/*0*/ selector: (T) -> kotlin.Long): kotlin.Long
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfUInt") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ T> kotlin.Array<out T>.sumOf(/*0*/ selector: (T) -> kotlin.UInt): kotlin.UInt
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfULong") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ T> kotlin.Array<out T>.sumOf(/*0*/ selector: (T) -> kotlin.ULong): kotlin.ULong
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfDouble") @kotlin.internal.InlineOnly public inline fun kotlin.BooleanArray.sumOf(/*0*/ selector: (kotlin.Boolean) -> kotlin.Double): kotlin.Double
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfInt") @kotlin.internal.InlineOnly public inline fun kotlin.BooleanArray.sumOf(/*0*/ selector: (kotlin.Boolean) -> kotlin.Int): kotlin.Int
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfLong") @kotlin.internal.InlineOnly public inline fun kotlin.BooleanArray.sumOf(/*0*/ selector: (kotlin.Boolean) -> kotlin.Long): kotlin.Long
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfUInt") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.BooleanArray.sumOf(/*0*/ selector: (kotlin.Boolean) -> kotlin.UInt): kotlin.UInt
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfULong") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.BooleanArray.sumOf(/*0*/ selector: (kotlin.Boolean) -> kotlin.ULong): kotlin.ULong
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfDouble") @kotlin.internal.InlineOnly public inline fun kotlin.ByteArray.sumOf(/*0*/ selector: (kotlin.Byte) -> kotlin.Double): kotlin.Double
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfInt") @kotlin.internal.InlineOnly public inline fun kotlin.ByteArray.sumOf(/*0*/ selector: (kotlin.Byte) -> kotlin.Int): kotlin.Int
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfLong") @kotlin.internal.InlineOnly public inline fun kotlin.ByteArray.sumOf(/*0*/ selector: (kotlin.Byte) -> kotlin.Long): kotlin.Long
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfUInt") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ByteArray.sumOf(/*0*/ selector: (kotlin.Byte) -> kotlin.UInt): kotlin.UInt
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfULong") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ByteArray.sumOf(/*0*/ selector: (kotlin.Byte) -> kotlin.ULong): kotlin.ULong
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfDouble") @kotlin.internal.InlineOnly public inline fun kotlin.CharArray.sumOf(/*0*/ selector: (kotlin.Char) -> kotlin.Double): kotlin.Double
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfInt") @kotlin.internal.InlineOnly public inline fun kotlin.CharArray.sumOf(/*0*/ selector: (kotlin.Char) -> kotlin.Int): kotlin.Int
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfLong") @kotlin.internal.InlineOnly public inline fun kotlin.CharArray.sumOf(/*0*/ selector: (kotlin.Char) -> kotlin.Long): kotlin.Long
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfUInt") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.CharArray.sumOf(/*0*/ selector: (kotlin.Char) -> kotlin.UInt): kotlin.UInt
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfULong") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.CharArray.sumOf(/*0*/ selector: (kotlin.Char) -> kotlin.ULong): kotlin.ULong
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfDouble") @kotlin.internal.InlineOnly public inline fun kotlin.DoubleArray.sumOf(/*0*/ selector: (kotlin.Double) -> kotlin.Double): kotlin.Double
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfInt") @kotlin.internal.InlineOnly public inline fun kotlin.DoubleArray.sumOf(/*0*/ selector: (kotlin.Double) -> kotlin.Int): kotlin.Int
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfLong") @kotlin.internal.InlineOnly public inline fun kotlin.DoubleArray.sumOf(/*0*/ selector: (kotlin.Double) -> kotlin.Long): kotlin.Long
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfUInt") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.DoubleArray.sumOf(/*0*/ selector: (kotlin.Double) -> kotlin.UInt): kotlin.UInt
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfULong") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.DoubleArray.sumOf(/*0*/ selector: (kotlin.Double) -> kotlin.ULong): kotlin.ULong
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfDouble") @kotlin.internal.InlineOnly public inline fun kotlin.FloatArray.sumOf(/*0*/ selector: (kotlin.Float) -> kotlin.Double): kotlin.Double
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfInt") @kotlin.internal.InlineOnly public inline fun kotlin.FloatArray.sumOf(/*0*/ selector: (kotlin.Float) -> kotlin.Int): kotlin.Int
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfLong") @kotlin.internal.InlineOnly public inline fun kotlin.FloatArray.sumOf(/*0*/ selector: (kotlin.Float) -> kotlin.Long): kotlin.Long
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfUInt") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.FloatArray.sumOf(/*0*/ selector: (kotlin.Float) -> kotlin.UInt): kotlin.UInt
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfULong") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.FloatArray.sumOf(/*0*/ selector: (kotlin.Float) -> kotlin.ULong): kotlin.ULong
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfDouble") @kotlin.internal.InlineOnly public inline fun kotlin.IntArray.sumOf(/*0*/ selector: (kotlin.Int) -> kotlin.Double): kotlin.Double
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfInt") @kotlin.internal.InlineOnly public inline fun kotlin.IntArray.sumOf(/*0*/ selector: (kotlin.Int) -> kotlin.Int): kotlin.Int
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfLong") @kotlin.internal.InlineOnly public inline fun kotlin.IntArray.sumOf(/*0*/ selector: (kotlin.Int) -> kotlin.Long): kotlin.Long
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfUInt") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.IntArray.sumOf(/*0*/ selector: (kotlin.Int) -> kotlin.UInt): kotlin.UInt
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfULong") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.IntArray.sumOf(/*0*/ selector: (kotlin.Int) -> kotlin.ULong): kotlin.ULong
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfDouble") @kotlin.internal.InlineOnly public inline fun kotlin.LongArray.sumOf(/*0*/ selector: (kotlin.Long) -> kotlin.Double): kotlin.Double
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfInt") @kotlin.internal.InlineOnly public inline fun kotlin.LongArray.sumOf(/*0*/ selector: (kotlin.Long) -> kotlin.Int): kotlin.Int
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfLong") @kotlin.internal.InlineOnly public inline fun kotlin.LongArray.sumOf(/*0*/ selector: (kotlin.Long) -> kotlin.Long): kotlin.Long
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfUInt") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.LongArray.sumOf(/*0*/ selector: (kotlin.Long) -> kotlin.UInt): kotlin.UInt
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfULong") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.LongArray.sumOf(/*0*/ selector: (kotlin.Long) -> kotlin.ULong): kotlin.ULong
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfDouble") @kotlin.internal.InlineOnly public inline fun kotlin.ShortArray.sumOf(/*0*/ selector: (kotlin.Short) -> kotlin.Double): kotlin.Double
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfInt") @kotlin.internal.InlineOnly public inline fun kotlin.ShortArray.sumOf(/*0*/ selector: (kotlin.Short) -> kotlin.Int): kotlin.Int
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfLong") @kotlin.internal.InlineOnly public inline fun kotlin.ShortArray.sumOf(/*0*/ selector: (kotlin.Short) -> kotlin.Long): kotlin.Long
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfUInt") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ShortArray.sumOf(/*0*/ selector: (kotlin.Short) -> kotlin.UInt): kotlin.UInt
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfULong") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ShortArray.sumOf(/*0*/ selector: (kotlin.Short) -> kotlin.ULong): kotlin.ULong
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfDouble") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UByteArray.sumOf(/*0*/ selector: (kotlin.UByte) -> kotlin.Double): kotlin.Double
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfInt") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UByteArray.sumOf(/*0*/ selector: (kotlin.UByte) -> kotlin.Int): kotlin.Int
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfLong") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UByteArray.sumOf(/*0*/ selector: (kotlin.UByte) -> kotlin.Long): kotlin.Long
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfUInt") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UByteArray.sumOf(/*0*/ selector: (kotlin.UByte) -> kotlin.UInt): kotlin.UInt
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfULong") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UByteArray.sumOf(/*0*/ selector: (kotlin.UByte) -> kotlin.ULong): kotlin.ULong
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfDouble") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UIntArray.sumOf(/*0*/ selector: (kotlin.UInt) -> kotlin.Double): kotlin.Double
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfInt") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UIntArray.sumOf(/*0*/ selector: (kotlin.UInt) -> kotlin.Int): kotlin.Int
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfLong") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UIntArray.sumOf(/*0*/ selector: (kotlin.UInt) -> kotlin.Long): kotlin.Long
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfUInt") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UIntArray.sumOf(/*0*/ selector: (kotlin.UInt) -> kotlin.UInt): kotlin.UInt
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfULong") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UIntArray.sumOf(/*0*/ selector: (kotlin.UInt) -> kotlin.ULong): kotlin.ULong
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfDouble") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ULongArray.sumOf(/*0*/ selector: (kotlin.ULong) -> kotlin.Double): kotlin.Double
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfInt") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ULongArray.sumOf(/*0*/ selector: (kotlin.ULong) -> kotlin.Int): kotlin.Int
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfLong") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ULongArray.sumOf(/*0*/ selector: (kotlin.ULong) -> kotlin.Long): kotlin.Long
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfUInt") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ULongArray.sumOf(/*0*/ selector: (kotlin.ULong) -> kotlin.UInt): kotlin.UInt
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfULong") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ULongArray.sumOf(/*0*/ selector: (kotlin.ULong) -> kotlin.ULong): kotlin.ULong
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfDouble") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UShortArray.sumOf(/*0*/ selector: (kotlin.UShort) -> kotlin.Double): kotlin.Double
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfInt") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UShortArray.sumOf(/*0*/ selector: (kotlin.UShort) -> kotlin.Int): kotlin.Int
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfLong") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UShortArray.sumOf(/*0*/ selector: (kotlin.UShort) -> kotlin.Long): kotlin.Long
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfUInt") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UShortArray.sumOf(/*0*/ selector: (kotlin.UShort) -> kotlin.UInt): kotlin.UInt
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfULong") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UShortArray.sumOf(/*0*/ selector: (kotlin.UShort) -> kotlin.ULong): kotlin.ULong
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfDouble") @kotlin.internal.InlineOnly public inline fun </*0*/ T> kotlin.collections.Iterable<T>.sumOf(/*0*/ selector: (T) -> kotlin.Double): kotlin.Double
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfInt") @kotlin.internal.InlineOnly public inline fun </*0*/ T> kotlin.collections.Iterable<T>.sumOf(/*0*/ selector: (T) -> kotlin.Int): kotlin.Int
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfLong") @kotlin.internal.InlineOnly public inline fun </*0*/ T> kotlin.collections.Iterable<T>.sumOf(/*0*/ selector: (T) -> kotlin.Long): kotlin.Long
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfUInt") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ T> kotlin.collections.Iterable<T>.sumOf(/*0*/ selector: (T) -> kotlin.UInt): kotlin.UInt
@kotlin.SinceKotlin(version = "1.4") @kotlin.OverloadResolutionByLambdaReturnType @kotlin.jvm.JvmName(name = "sumOfULong") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ T> kotlin.collections.Iterable<T>.sumOf(/*0*/ selector: (T) -> kotlin.ULong): kotlin.ULong
public fun </*0*/ T> kotlin.Array<out T>.take(/*0*/ n: kotlin.Int): kotlin.collections.List<T>
public fun kotlin.BooleanArray.take(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.Boolean>
public fun kotlin.ByteArray.take(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.Byte>
public fun kotlin.CharArray.take(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.Char>
public fun kotlin.DoubleArray.take(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.Double>
public fun kotlin.FloatArray.take(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.Float>
public fun kotlin.IntArray.take(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.Int>
public fun kotlin.LongArray.take(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.Long>
public fun kotlin.ShortArray.take(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.Short>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.take(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.UByte>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.take(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.UInt>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.take(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.ULong>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.take(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.UShort>
public fun </*0*/ T> kotlin.collections.Iterable<T>.take(/*0*/ n: kotlin.Int): kotlin.collections.List<T>
public fun </*0*/ T> kotlin.Array<out T>.takeLast(/*0*/ n: kotlin.Int): kotlin.collections.List<T>
public fun kotlin.BooleanArray.takeLast(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.Boolean>
public fun kotlin.ByteArray.takeLast(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.Byte>
public fun kotlin.CharArray.takeLast(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.Char>
public fun kotlin.DoubleArray.takeLast(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.Double>
public fun kotlin.FloatArray.takeLast(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.Float>
public fun kotlin.IntArray.takeLast(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.Int>
public fun kotlin.LongArray.takeLast(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.Long>
public fun kotlin.ShortArray.takeLast(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.Short>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.takeLast(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.UByte>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.takeLast(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.UInt>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.takeLast(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.ULong>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.takeLast(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.UShort>
public fun </*0*/ T> kotlin.collections.List<T>.takeLast(/*0*/ n: kotlin.Int): kotlin.collections.List<T>
public inline fun </*0*/ T> kotlin.Array<out T>.takeLastWhile(/*0*/ predicate: (T) -> kotlin.Boolean): kotlin.collections.List<T>
public inline fun kotlin.BooleanArray.takeLastWhile(/*0*/ predicate: (kotlin.Boolean) -> kotlin.Boolean): kotlin.collections.List<kotlin.Boolean>
public inline fun kotlin.ByteArray.takeLastWhile(/*0*/ predicate: (kotlin.Byte) -> kotlin.Boolean): kotlin.collections.List<kotlin.Byte>
public inline fun kotlin.CharArray.takeLastWhile(/*0*/ predicate: (kotlin.Char) -> kotlin.Boolean): kotlin.collections.List<kotlin.Char>
public inline fun kotlin.DoubleArray.takeLastWhile(/*0*/ predicate: (kotlin.Double) -> kotlin.Boolean): kotlin.collections.List<kotlin.Double>
public inline fun kotlin.FloatArray.takeLastWhile(/*0*/ predicate: (kotlin.Float) -> kotlin.Boolean): kotlin.collections.List<kotlin.Float>
public inline fun kotlin.IntArray.takeLastWhile(/*0*/ predicate: (kotlin.Int) -> kotlin.Boolean): kotlin.collections.List<kotlin.Int>
public inline fun kotlin.LongArray.takeLastWhile(/*0*/ predicate: (kotlin.Long) -> kotlin.Boolean): kotlin.collections.List<kotlin.Long>
public inline fun kotlin.ShortArray.takeLastWhile(/*0*/ predicate: (kotlin.Short) -> kotlin.Boolean): kotlin.collections.List<kotlin.Short>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UByteArray.takeLastWhile(/*0*/ predicate: (kotlin.UByte) -> kotlin.Boolean): kotlin.collections.List<kotlin.UByte>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UIntArray.takeLastWhile(/*0*/ predicate: (kotlin.UInt) -> kotlin.Boolean): kotlin.collections.List<kotlin.UInt>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ULongArray.takeLastWhile(/*0*/ predicate: (kotlin.ULong) -> kotlin.Boolean): kotlin.collections.List<kotlin.ULong>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UShortArray.takeLastWhile(/*0*/ predicate: (kotlin.UShort) -> kotlin.Boolean): kotlin.collections.List<kotlin.UShort>
public inline fun </*0*/ T> kotlin.collections.List<T>.takeLastWhile(/*0*/ predicate: (T) -> kotlin.Boolean): kotlin.collections.List<T>
public inline fun </*0*/ T> kotlin.Array<out T>.takeWhile(/*0*/ predicate: (T) -> kotlin.Boolean): kotlin.collections.List<T>
public inline fun kotlin.BooleanArray.takeWhile(/*0*/ predicate: (kotlin.Boolean) -> kotlin.Boolean): kotlin.collections.List<kotlin.Boolean>
public inline fun kotlin.ByteArray.takeWhile(/*0*/ predicate: (kotlin.Byte) -> kotlin.Boolean): kotlin.collections.List<kotlin.Byte>
public inline fun kotlin.CharArray.takeWhile(/*0*/ predicate: (kotlin.Char) -> kotlin.Boolean): kotlin.collections.List<kotlin.Char>
public inline fun kotlin.DoubleArray.takeWhile(/*0*/ predicate: (kotlin.Double) -> kotlin.Boolean): kotlin.collections.List<kotlin.Double>
public inline fun kotlin.FloatArray.takeWhile(/*0*/ predicate: (kotlin.Float) -> kotlin.Boolean): kotlin.collections.List<kotlin.Float>
public inline fun kotlin.IntArray.takeWhile(/*0*/ predicate: (kotlin.Int) -> kotlin.Boolean): kotlin.collections.List<kotlin.Int>
public inline fun kotlin.LongArray.takeWhile(/*0*/ predicate: (kotlin.Long) -> kotlin.Boolean): kotlin.collections.List<kotlin.Long>
public inline fun kotlin.ShortArray.takeWhile(/*0*/ predicate: (kotlin.Short) -> kotlin.Boolean): kotlin.collections.List<kotlin.Short>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UByteArray.takeWhile(/*0*/ predicate: (kotlin.UByte) -> kotlin.Boolean): kotlin.collections.List<kotlin.UByte>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UIntArray.takeWhile(/*0*/ predicate: (kotlin.UInt) -> kotlin.Boolean): kotlin.collections.List<kotlin.UInt>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ULongArray.takeWhile(/*0*/ predicate: (kotlin.ULong) -> kotlin.Boolean): kotlin.collections.List<kotlin.ULong>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UShortArray.takeWhile(/*0*/ predicate: (kotlin.UShort) -> kotlin.Boolean): kotlin.collections.List<kotlin.UShort>
public inline fun </*0*/ T> kotlin.collections.Iterable<T>.takeWhile(/*0*/ predicate: (T) -> kotlin.Boolean): kotlin.collections.List<T>
public fun kotlin.Array<out kotlin.Boolean>.toBooleanArray(): kotlin.BooleanArray
public fun kotlin.collections.Collection<kotlin.Boolean>.toBooleanArray(): kotlin.BooleanArray
public fun kotlin.Array<out kotlin.Byte>.toByteArray(): kotlin.ByteArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UByteArray.toByteArray(): kotlin.ByteArray
public fun kotlin.collections.Collection<kotlin.Byte>.toByteArray(): kotlin.ByteArray
public fun kotlin.Array<out kotlin.Char>.toCharArray(): kotlin.CharArray
public fun kotlin.collections.Collection<kotlin.Char>.toCharArray(): kotlin.CharArray
public fun </*0*/ T, /*1*/ C : kotlin.collections.MutableCollection<in T>> kotlin.Array<out T>.toCollection(/*0*/ destination: C): C
public fun </*0*/ C : kotlin.collections.MutableCollection<in kotlin.Boolean>> kotlin.BooleanArray.toCollection(/*0*/ destination: C): C
public fun </*0*/ C : kotlin.collections.MutableCollection<in kotlin.Byte>> kotlin.ByteArray.toCollection(/*0*/ destination: C): C
public fun </*0*/ C : kotlin.collections.MutableCollection<in kotlin.Char>> kotlin.CharArray.toCollection(/*0*/ destination: C): C
public fun </*0*/ C : kotlin.collections.MutableCollection<in kotlin.Double>> kotlin.DoubleArray.toCollection(/*0*/ destination: C): C
public fun </*0*/ C : kotlin.collections.MutableCollection<in kotlin.Float>> kotlin.FloatArray.toCollection(/*0*/ destination: C): C
public fun </*0*/ C : kotlin.collections.MutableCollection<in kotlin.Int>> kotlin.IntArray.toCollection(/*0*/ destination: C): C
public fun </*0*/ C : kotlin.collections.MutableCollection<in kotlin.Long>> kotlin.LongArray.toCollection(/*0*/ destination: C): C
public fun </*0*/ C : kotlin.collections.MutableCollection<in kotlin.Short>> kotlin.ShortArray.toCollection(/*0*/ destination: C): C
public fun </*0*/ T, /*1*/ C : kotlin.collections.MutableCollection<in T>> kotlin.collections.Iterable<T>.toCollection(/*0*/ destination: C): C
public fun kotlin.Array<out kotlin.Double>.toDoubleArray(): kotlin.DoubleArray
public fun kotlin.collections.Collection<kotlin.Double>.toDoubleArray(): kotlin.DoubleArray
public fun kotlin.Array<out kotlin.Float>.toFloatArray(): kotlin.FloatArray
public fun kotlin.collections.Collection<kotlin.Float>.toFloatArray(): kotlin.FloatArray
public fun </*0*/ T> kotlin.Array<out T>.toHashSet(): kotlin.collections.HashSet<T>
public fun kotlin.BooleanArray.toHashSet(): kotlin.collections.HashSet<kotlin.Boolean>
public fun kotlin.ByteArray.toHashSet(): kotlin.collections.HashSet<kotlin.Byte>
public fun kotlin.CharArray.toHashSet(): kotlin.collections.HashSet<kotlin.Char>
public fun kotlin.DoubleArray.toHashSet(): kotlin.collections.HashSet<kotlin.Double>
public fun kotlin.FloatArray.toHashSet(): kotlin.collections.HashSet<kotlin.Float>
public fun kotlin.IntArray.toHashSet(): kotlin.collections.HashSet<kotlin.Int>
public fun kotlin.LongArray.toHashSet(): kotlin.collections.HashSet<kotlin.Long>
public fun kotlin.ShortArray.toHashSet(): kotlin.collections.HashSet<kotlin.Short>
public fun </*0*/ T> kotlin.collections.Iterable<T>.toHashSet(): kotlin.collections.HashSet<T>
public fun kotlin.Array<out kotlin.Int>.toIntArray(): kotlin.IntArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UIntArray.toIntArray(): kotlin.IntArray
public fun kotlin.collections.Collection<kotlin.Int>.toIntArray(): kotlin.IntArray
public fun </*0*/ T> kotlin.Array<out T>.toList(): kotlin.collections.List<T>
public fun kotlin.BooleanArray.toList(): kotlin.collections.List<kotlin.Boolean>
public fun kotlin.ByteArray.toList(): kotlin.collections.List<kotlin.Byte>
public fun kotlin.CharArray.toList(): kotlin.collections.List<kotlin.Char>
public fun kotlin.DoubleArray.toList(): kotlin.collections.List<kotlin.Double>
public fun kotlin.FloatArray.toList(): kotlin.collections.List<kotlin.Float>
public fun kotlin.IntArray.toList(): kotlin.collections.List<kotlin.Int>
public fun kotlin.LongArray.toList(): kotlin.collections.List<kotlin.Long>
public fun kotlin.ShortArray.toList(): kotlin.collections.List<kotlin.Short>
public fun </*0*/ T> kotlin.collections.Iterable<T>.toList(): kotlin.collections.List<T>
public fun </*0*/ K, /*1*/ V> kotlin.collections.Map<out K, V>.toList(): kotlin.collections.List<kotlin.Pair<K, V>>
public fun kotlin.Array<out kotlin.Long>.toLongArray(): kotlin.LongArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ULongArray.toLongArray(): kotlin.LongArray
public fun kotlin.collections.Collection<kotlin.Long>.toLongArray(): kotlin.LongArray
public fun </*0*/ K, /*1*/ V> kotlin.Array<out kotlin.Pair<K, V>>.toMap(): kotlin.collections.Map<K, V>
public fun </*0*/ K, /*1*/ V, /*2*/ M : kotlin.collections.MutableMap<in K, in V>> kotlin.Array<out kotlin.Pair<K, V>>.toMap(/*0*/ destination: M): M
public fun </*0*/ K, /*1*/ V> kotlin.collections.Iterable<kotlin.Pair<K, V>>.toMap(): kotlin.collections.Map<K, V>
public fun </*0*/ K, /*1*/ V, /*2*/ M : kotlin.collections.MutableMap<in K, in V>> kotlin.collections.Iterable<kotlin.Pair<K, V>>.toMap(/*0*/ destination: M): M
@kotlin.SinceKotlin(version = "1.1") public fun </*0*/ K, /*1*/ V> kotlin.collections.Map<out K, V>.toMap(): kotlin.collections.Map<K, V>
@kotlin.SinceKotlin(version = "1.1") public fun </*0*/ K, /*1*/ V, /*2*/ M : kotlin.collections.MutableMap<in K, in V>> kotlin.collections.Map<out K, V>.toMap(/*0*/ destination: M): M
public fun </*0*/ K, /*1*/ V> kotlin.sequences.Sequence<kotlin.Pair<K, V>>.toMap(): kotlin.collections.Map<K, V>
public fun </*0*/ K, /*1*/ V, /*2*/ M : kotlin.collections.MutableMap<in K, in V>> kotlin.sequences.Sequence<kotlin.Pair<K, V>>.toMap(/*0*/ destination: M): M
public fun </*0*/ T> kotlin.Array<out T>.toMutableList(): kotlin.collections.MutableList<T>
public fun kotlin.BooleanArray.toMutableList(): kotlin.collections.MutableList<kotlin.Boolean>
public fun kotlin.ByteArray.toMutableList(): kotlin.collections.MutableList<kotlin.Byte>
public fun kotlin.CharArray.toMutableList(): kotlin.collections.MutableList<kotlin.Char>
public fun kotlin.DoubleArray.toMutableList(): kotlin.collections.MutableList<kotlin.Double>
public fun kotlin.FloatArray.toMutableList(): kotlin.collections.MutableList<kotlin.Float>
public fun kotlin.IntArray.toMutableList(): kotlin.collections.MutableList<kotlin.Int>
public fun kotlin.LongArray.toMutableList(): kotlin.collections.MutableList<kotlin.Long>
public fun kotlin.ShortArray.toMutableList(): kotlin.collections.MutableList<kotlin.Short>
public fun </*0*/ T> kotlin.collections.Collection<T>.toMutableList(): kotlin.collections.MutableList<T>
public fun </*0*/ T> kotlin.collections.Iterable<T>.toMutableList(): kotlin.collections.MutableList<T>
@kotlin.SinceKotlin(version = "1.1") public fun </*0*/ K, /*1*/ V> kotlin.collections.Map<out K, V>.toMutableMap(): kotlin.collections.MutableMap<K, V>
public fun </*0*/ T> kotlin.Array<out T>.toMutableSet(): kotlin.collections.MutableSet<T>
public fun kotlin.BooleanArray.toMutableSet(): kotlin.collections.MutableSet<kotlin.Boolean>
public fun kotlin.ByteArray.toMutableSet(): kotlin.collections.MutableSet<kotlin.Byte>
public fun kotlin.CharArray.toMutableSet(): kotlin.collections.MutableSet<kotlin.Char>
public fun kotlin.DoubleArray.toMutableSet(): kotlin.collections.MutableSet<kotlin.Double>
public fun kotlin.FloatArray.toMutableSet(): kotlin.collections.MutableSet<kotlin.Float>
public fun kotlin.IntArray.toMutableSet(): kotlin.collections.MutableSet<kotlin.Int>
public fun kotlin.LongArray.toMutableSet(): kotlin.collections.MutableSet<kotlin.Long>
public fun kotlin.ShortArray.toMutableSet(): kotlin.collections.MutableSet<kotlin.Short>
public fun </*0*/ T> kotlin.collections.Iterable<T>.toMutableSet(): kotlin.collections.MutableSet<T>
@kotlin.internal.InlineOnly public inline fun </*0*/ K, /*1*/ V> kotlin.collections.Map.Entry<K, V>.toPair(): kotlin.Pair<K, V>
public fun </*0*/ T> kotlin.Array<out T>.toSet(): kotlin.collections.Set<T>
public fun kotlin.BooleanArray.toSet(): kotlin.collections.Set<kotlin.Boolean>
public fun kotlin.ByteArray.toSet(): kotlin.collections.Set<kotlin.Byte>
public fun kotlin.CharArray.toSet(): kotlin.collections.Set<kotlin.Char>
public fun kotlin.DoubleArray.toSet(): kotlin.collections.Set<kotlin.Double>
public fun kotlin.FloatArray.toSet(): kotlin.collections.Set<kotlin.Float>
public fun kotlin.IntArray.toSet(): kotlin.collections.Set<kotlin.Int>
public fun kotlin.LongArray.toSet(): kotlin.collections.Set<kotlin.Long>
public fun kotlin.ShortArray.toSet(): kotlin.collections.Set<kotlin.Short>
public fun </*0*/ T> kotlin.collections.Iterable<T>.toSet(): kotlin.collections.Set<T>
public fun kotlin.Array<out kotlin.Short>.toShortArray(): kotlin.ShortArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UShortArray.toShortArray(): kotlin.ShortArray
public fun kotlin.collections.Collection<kotlin.Short>.toShortArray(): kotlin.ShortArray
public fun kotlin.BooleanArray.toTypedArray(): kotlin.Array<kotlin.Boolean>
public fun kotlin.ByteArray.toTypedArray(): kotlin.Array<kotlin.Byte>
public fun kotlin.CharArray.toTypedArray(): kotlin.Array<kotlin.Char>
public fun kotlin.DoubleArray.toTypedArray(): kotlin.Array<kotlin.Double>
public fun kotlin.FloatArray.toTypedArray(): kotlin.Array<kotlin.Float>
public fun kotlin.IntArray.toTypedArray(): kotlin.Array<kotlin.Int>
public fun kotlin.LongArray.toTypedArray(): kotlin.Array<kotlin.Long>
public fun kotlin.ShortArray.toTypedArray(): kotlin.Array<kotlin.Short>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.toTypedArray(): kotlin.Array<kotlin.UByte>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.toTypedArray(): kotlin.Array<kotlin.UInt>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.toTypedArray(): kotlin.Array<kotlin.ULong>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.toTypedArray(): kotlin.Array<kotlin.UShort>
@kotlin.internal.InlineOnly public inline fun </*0*/ T> kotlin.collections.Collection<T>.toTypedArray(): kotlin.Array<T>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.Array<out kotlin.UByte>.toUByteArray(): kotlin.UByteArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ByteArray.toUByteArray(): kotlin.UByteArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.collections.Collection<kotlin.UByte>.toUByteArray(): kotlin.UByteArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.Array<out kotlin.UInt>.toUIntArray(): kotlin.UIntArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.IntArray.toUIntArray(): kotlin.UIntArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.collections.Collection<kotlin.UInt>.toUIntArray(): kotlin.UIntArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.Array<out kotlin.ULong>.toULongArray(): kotlin.ULongArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.LongArray.toULongArray(): kotlin.ULongArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.collections.Collection<kotlin.ULong>.toULongArray(): kotlin.ULongArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.Array<out kotlin.UShort>.toUShortArray(): kotlin.UShortArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ShortArray.toUShortArray(): kotlin.UShortArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.collections.Collection<kotlin.UShort>.toUShortArray(): kotlin.UShortArray
public infix fun </*0*/ T> kotlin.Array<out T>.union(/*0*/ other: kotlin.collections.Iterable<T>): kotlin.collections.Set<T>
public infix fun kotlin.BooleanArray.union(/*0*/ other: kotlin.collections.Iterable<kotlin.Boolean>): kotlin.collections.Set<kotlin.Boolean>
public infix fun kotlin.ByteArray.union(/*0*/ other: kotlin.collections.Iterable<kotlin.Byte>): kotlin.collections.Set<kotlin.Byte>
public infix fun kotlin.CharArray.union(/*0*/ other: kotlin.collections.Iterable<kotlin.Char>): kotlin.collections.Set<kotlin.Char>
public infix fun kotlin.DoubleArray.union(/*0*/ other: kotlin.collections.Iterable<kotlin.Double>): kotlin.collections.Set<kotlin.Double>
public infix fun kotlin.FloatArray.union(/*0*/ other: kotlin.collections.Iterable<kotlin.Float>): kotlin.collections.Set<kotlin.Float>
public infix fun kotlin.IntArray.union(/*0*/ other: kotlin.collections.Iterable<kotlin.Int>): kotlin.collections.Set<kotlin.Int>
public infix fun kotlin.LongArray.union(/*0*/ other: kotlin.collections.Iterable<kotlin.Long>): kotlin.collections.Set<kotlin.Long>
public infix fun kotlin.ShortArray.union(/*0*/ other: kotlin.collections.Iterable<kotlin.Short>): kotlin.collections.Set<kotlin.Short>
public infix fun </*0*/ T> kotlin.collections.Iterable<T>.union(/*0*/ other: kotlin.collections.Iterable<T>): kotlin.collections.Set<T>
public fun </*0*/ T, /*1*/ R> kotlin.Array<out kotlin.Pair<T, R>>.unzip(): kotlin.Pair<kotlin.collections.List<T>, kotlin.collections.List<R>>
public fun </*0*/ T, /*1*/ R> kotlin.collections.Iterable<kotlin.Pair<T, R>>.unzip(): kotlin.Pair<kotlin.collections.List<T>, kotlin.collections.List<R>>
@kotlin.SinceKotlin(version = "1.2") public fun </*0*/ T> kotlin.collections.Iterable<T>.windowed(/*0*/ size: kotlin.Int, /*1*/ step: kotlin.Int = ..., /*2*/ partialWindows: kotlin.Boolean = ...): kotlin.collections.List<kotlin.collections.List<T>>
@kotlin.SinceKotlin(version = "1.2") public fun </*0*/ T, /*1*/ R> kotlin.collections.Iterable<T>.windowed(/*0*/ size: kotlin.Int, /*1*/ step: kotlin.Int = ..., /*2*/ partialWindows: kotlin.Boolean = ..., /*3*/ transform: (kotlin.collections.List<T>) -> R): kotlin.collections.List<R>
public fun </*0*/ K, /*1*/ V> kotlin.collections.Map<K, V>.withDefault(/*0*/ defaultValue: (key: K) -> V): kotlin.collections.Map<K, V>
@kotlin.jvm.JvmName(name = "withDefaultMutable") public fun </*0*/ K, /*1*/ V> kotlin.collections.MutableMap<K, V>.withDefault(/*0*/ defaultValue: (key: K) -> V): kotlin.collections.MutableMap<K, V>
public fun </*0*/ T> kotlin.Array<out T>.withIndex(): kotlin.collections.Iterable<kotlin.collections.IndexedValue<T>>
public fun kotlin.BooleanArray.withIndex(): kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Boolean>>
public fun kotlin.ByteArray.withIndex(): kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Byte>>
public fun kotlin.CharArray.withIndex(): kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Char>>
public fun kotlin.DoubleArray.withIndex(): kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Double>>
public fun kotlin.FloatArray.withIndex(): kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Float>>
public fun kotlin.IntArray.withIndex(): kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
public fun kotlin.LongArray.withIndex(): kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Long>>
public fun kotlin.ShortArray.withIndex(): kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Short>>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.withIndex(): kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.UByte>>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.withIndex(): kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.UInt>>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.withIndex(): kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.ULong>>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.withIndex(): kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.UShort>>
public fun </*0*/ T> kotlin.collections.Iterable<T>.withIndex(): kotlin.collections.Iterable<kotlin.collections.IndexedValue<T>>
public fun </*0*/ T> kotlin.collections.Iterator<T>.withIndex(): kotlin.collections.Iterator<kotlin.collections.IndexedValue<T>>
public infix fun </*0*/ T, /*1*/ R> kotlin.Array<out T>.zip(/*0*/ other: kotlin.Array<out R>): kotlin.collections.List<kotlin.Pair<T, R>>
public inline fun </*0*/ T, /*1*/ R, /*2*/ V> kotlin.Array<out T>.zip(/*0*/ other: kotlin.Array<out R>, /*1*/ transform: (a: T, b: R) -> V): kotlin.collections.List<V>
public infix fun </*0*/ T, /*1*/ R> kotlin.Array<out T>.zip(/*0*/ other: kotlin.collections.Iterable<R>): kotlin.collections.List<kotlin.Pair<T, R>>
public inline fun </*0*/ T, /*1*/ R, /*2*/ V> kotlin.Array<out T>.zip(/*0*/ other: kotlin.collections.Iterable<R>, /*1*/ transform: (a: T, b: R) -> V): kotlin.collections.List<V>
public infix fun </*0*/ R> kotlin.BooleanArray.zip(/*0*/ other: kotlin.Array<out R>): kotlin.collections.List<kotlin.Pair<kotlin.Boolean, R>>
public inline fun </*0*/ R, /*1*/ V> kotlin.BooleanArray.zip(/*0*/ other: kotlin.Array<out R>, /*1*/ transform: (a: kotlin.Boolean, b: R) -> V): kotlin.collections.List<V>
public infix fun kotlin.BooleanArray.zip(/*0*/ other: kotlin.BooleanArray): kotlin.collections.List<kotlin.Pair<kotlin.Boolean, kotlin.Boolean>>
public inline fun </*0*/ V> kotlin.BooleanArray.zip(/*0*/ other: kotlin.BooleanArray, /*1*/ transform: (a: kotlin.Boolean, b: kotlin.Boolean) -> V): kotlin.collections.List<V>
public infix fun </*0*/ R> kotlin.BooleanArray.zip(/*0*/ other: kotlin.collections.Iterable<R>): kotlin.collections.List<kotlin.Pair<kotlin.Boolean, R>>
public inline fun </*0*/ R, /*1*/ V> kotlin.BooleanArray.zip(/*0*/ other: kotlin.collections.Iterable<R>, /*1*/ transform: (a: kotlin.Boolean, b: R) -> V): kotlin.collections.List<V>
public infix fun </*0*/ R> kotlin.ByteArray.zip(/*0*/ other: kotlin.Array<out R>): kotlin.collections.List<kotlin.Pair<kotlin.Byte, R>>
public inline fun </*0*/ R, /*1*/ V> kotlin.ByteArray.zip(/*0*/ other: kotlin.Array<out R>, /*1*/ transform: (a: kotlin.Byte, b: R) -> V): kotlin.collections.List<V>
public infix fun kotlin.ByteArray.zip(/*0*/ other: kotlin.ByteArray): kotlin.collections.List<kotlin.Pair<kotlin.Byte, kotlin.Byte>>
public inline fun </*0*/ V> kotlin.ByteArray.zip(/*0*/ other: kotlin.ByteArray, /*1*/ transform: (a: kotlin.Byte, b: kotlin.Byte) -> V): kotlin.collections.List<V>
public infix fun </*0*/ R> kotlin.ByteArray.zip(/*0*/ other: kotlin.collections.Iterable<R>): kotlin.collections.List<kotlin.Pair<kotlin.Byte, R>>
public inline fun </*0*/ R, /*1*/ V> kotlin.ByteArray.zip(/*0*/ other: kotlin.collections.Iterable<R>, /*1*/ transform: (a: kotlin.Byte, b: R) -> V): kotlin.collections.List<V>
public infix fun </*0*/ R> kotlin.CharArray.zip(/*0*/ other: kotlin.Array<out R>): kotlin.collections.List<kotlin.Pair<kotlin.Char, R>>
public inline fun </*0*/ R, /*1*/ V> kotlin.CharArray.zip(/*0*/ other: kotlin.Array<out R>, /*1*/ transform: (a: kotlin.Char, b: R) -> V): kotlin.collections.List<V>
public infix fun kotlin.CharArray.zip(/*0*/ other: kotlin.CharArray): kotlin.collections.List<kotlin.Pair<kotlin.Char, kotlin.Char>>
public inline fun </*0*/ V> kotlin.CharArray.zip(/*0*/ other: kotlin.CharArray, /*1*/ transform: (a: kotlin.Char, b: kotlin.Char) -> V): kotlin.collections.List<V>
public infix fun </*0*/ R> kotlin.CharArray.zip(/*0*/ other: kotlin.collections.Iterable<R>): kotlin.collections.List<kotlin.Pair<kotlin.Char, R>>
public inline fun </*0*/ R, /*1*/ V> kotlin.CharArray.zip(/*0*/ other: kotlin.collections.Iterable<R>, /*1*/ transform: (a: kotlin.Char, b: R) -> V): kotlin.collections.List<V>
public infix fun </*0*/ R> kotlin.DoubleArray.zip(/*0*/ other: kotlin.Array<out R>): kotlin.collections.List<kotlin.Pair<kotlin.Double, R>>
public inline fun </*0*/ R, /*1*/ V> kotlin.DoubleArray.zip(/*0*/ other: kotlin.Array<out R>, /*1*/ transform: (a: kotlin.Double, b: R) -> V): kotlin.collections.List<V>
public infix fun kotlin.DoubleArray.zip(/*0*/ other: kotlin.DoubleArray): kotlin.collections.List<kotlin.Pair<kotlin.Double, kotlin.Double>>
public inline fun </*0*/ V> kotlin.DoubleArray.zip(/*0*/ other: kotlin.DoubleArray, /*1*/ transform: (a: kotlin.Double, b: kotlin.Double) -> V): kotlin.collections.List<V>
public infix fun </*0*/ R> kotlin.DoubleArray.zip(/*0*/ other: kotlin.collections.Iterable<R>): kotlin.collections.List<kotlin.Pair<kotlin.Double, R>>
public inline fun </*0*/ R, /*1*/ V> kotlin.DoubleArray.zip(/*0*/ other: kotlin.collections.Iterable<R>, /*1*/ transform: (a: kotlin.Double, b: R) -> V): kotlin.collections.List<V>
public infix fun </*0*/ R> kotlin.FloatArray.zip(/*0*/ other: kotlin.Array<out R>): kotlin.collections.List<kotlin.Pair<kotlin.Float, R>>
public inline fun </*0*/ R, /*1*/ V> kotlin.FloatArray.zip(/*0*/ other: kotlin.Array<out R>, /*1*/ transform: (a: kotlin.Float, b: R) -> V): kotlin.collections.List<V>
public infix fun kotlin.FloatArray.zip(/*0*/ other: kotlin.FloatArray): kotlin.collections.List<kotlin.Pair<kotlin.Float, kotlin.Float>>
public inline fun </*0*/ V> kotlin.FloatArray.zip(/*0*/ other: kotlin.FloatArray, /*1*/ transform: (a: kotlin.Float, b: kotlin.Float) -> V): kotlin.collections.List<V>
public infix fun </*0*/ R> kotlin.FloatArray.zip(/*0*/ other: kotlin.collections.Iterable<R>): kotlin.collections.List<kotlin.Pair<kotlin.Float, R>>
public inline fun </*0*/ R, /*1*/ V> kotlin.FloatArray.zip(/*0*/ other: kotlin.collections.Iterable<R>, /*1*/ transform: (a: kotlin.Float, b: R) -> V): kotlin.collections.List<V>
public infix fun </*0*/ R> kotlin.IntArray.zip(/*0*/ other: kotlin.Array<out R>): kotlin.collections.List<kotlin.Pair<kotlin.Int, R>>
public inline fun </*0*/ R, /*1*/ V> kotlin.IntArray.zip(/*0*/ other: kotlin.Array<out R>, /*1*/ transform: (a: kotlin.Int, b: R) -> V): kotlin.collections.List<V>
public infix fun kotlin.IntArray.zip(/*0*/ other: kotlin.IntArray): kotlin.collections.List<kotlin.Pair<kotlin.Int, kotlin.Int>>
public inline fun </*0*/ V> kotlin.IntArray.zip(/*0*/ other: kotlin.IntArray, /*1*/ transform: (a: kotlin.Int, b: kotlin.Int) -> V): kotlin.collections.List<V>
public infix fun </*0*/ R> kotlin.IntArray.zip(/*0*/ other: kotlin.collections.Iterable<R>): kotlin.collections.List<kotlin.Pair<kotlin.Int, R>>
public inline fun </*0*/ R, /*1*/ V> kotlin.IntArray.zip(/*0*/ other: kotlin.collections.Iterable<R>, /*1*/ transform: (a: kotlin.Int, b: R) -> V): kotlin.collections.List<V>
public infix fun </*0*/ R> kotlin.LongArray.zip(/*0*/ other: kotlin.Array<out R>): kotlin.collections.List<kotlin.Pair<kotlin.Long, R>>
public inline fun </*0*/ R, /*1*/ V> kotlin.LongArray.zip(/*0*/ other: kotlin.Array<out R>, /*1*/ transform: (a: kotlin.Long, b: R) -> V): kotlin.collections.List<V>
public infix fun kotlin.LongArray.zip(/*0*/ other: kotlin.LongArray): kotlin.collections.List<kotlin.Pair<kotlin.Long, kotlin.Long>>
public inline fun </*0*/ V> kotlin.LongArray.zip(/*0*/ other: kotlin.LongArray, /*1*/ transform: (a: kotlin.Long, b: kotlin.Long) -> V): kotlin.collections.List<V>
public infix fun </*0*/ R> kotlin.LongArray.zip(/*0*/ other: kotlin.collections.Iterable<R>): kotlin.collections.List<kotlin.Pair<kotlin.Long, R>>
public inline fun </*0*/ R, /*1*/ V> kotlin.LongArray.zip(/*0*/ other: kotlin.collections.Iterable<R>, /*1*/ transform: (a: kotlin.Long, b: R) -> V): kotlin.collections.List<V>
public infix fun </*0*/ R> kotlin.ShortArray.zip(/*0*/ other: kotlin.Array<out R>): kotlin.collections.List<kotlin.Pair<kotlin.Short, R>>
public inline fun </*0*/ R, /*1*/ V> kotlin.ShortArray.zip(/*0*/ other: kotlin.Array<out R>, /*1*/ transform: (a: kotlin.Short, b: R) -> V): kotlin.collections.List<V>
public infix fun kotlin.ShortArray.zip(/*0*/ other: kotlin.ShortArray): kotlin.collections.List<kotlin.Pair<kotlin.Short, kotlin.Short>>
public inline fun </*0*/ V> kotlin.ShortArray.zip(/*0*/ other: kotlin.ShortArray, /*1*/ transform: (a: kotlin.Short, b: kotlin.Short) -> V): kotlin.collections.List<V>
public infix fun </*0*/ R> kotlin.ShortArray.zip(/*0*/ other: kotlin.collections.Iterable<R>): kotlin.collections.List<kotlin.Pair<kotlin.Short, R>>
public inline fun </*0*/ R, /*1*/ V> kotlin.ShortArray.zip(/*0*/ other: kotlin.collections.Iterable<R>, /*1*/ transform: (a: kotlin.Short, b: R) -> V): kotlin.collections.List<V>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public infix fun </*0*/ R> kotlin.UByteArray.zip(/*0*/ other: kotlin.Array<out R>): kotlin.collections.List<kotlin.Pair<kotlin.UByte, R>>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ R, /*1*/ V> kotlin.UByteArray.zip(/*0*/ other: kotlin.Array<out R>, /*1*/ transform: (a: kotlin.UByte, b: R) -> V): kotlin.collections.List<V>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public infix fun kotlin.UByteArray.zip(/*0*/ other: kotlin.UByteArray): kotlin.collections.List<kotlin.Pair<kotlin.UByte, kotlin.UByte>>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ V> kotlin.UByteArray.zip(/*0*/ other: kotlin.UByteArray, /*1*/ transform: (a: kotlin.UByte, b: kotlin.UByte) -> V): kotlin.collections.List<V>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public infix fun </*0*/ R> kotlin.UByteArray.zip(/*0*/ other: kotlin.collections.Iterable<R>): kotlin.collections.List<kotlin.Pair<kotlin.UByte, R>>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ R, /*1*/ V> kotlin.UByteArray.zip(/*0*/ other: kotlin.collections.Iterable<R>, /*1*/ transform: (a: kotlin.UByte, b: R) -> V): kotlin.collections.List<V>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public infix fun </*0*/ R> kotlin.UIntArray.zip(/*0*/ other: kotlin.Array<out R>): kotlin.collections.List<kotlin.Pair<kotlin.UInt, R>>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ R, /*1*/ V> kotlin.UIntArray.zip(/*0*/ other: kotlin.Array<out R>, /*1*/ transform: (a: kotlin.UInt, b: R) -> V): kotlin.collections.List<V>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public infix fun kotlin.UIntArray.zip(/*0*/ other: kotlin.UIntArray): kotlin.collections.List<kotlin.Pair<kotlin.UInt, kotlin.UInt>>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ V> kotlin.UIntArray.zip(/*0*/ other: kotlin.UIntArray, /*1*/ transform: (a: kotlin.UInt, b: kotlin.UInt) -> V): kotlin.collections.List<V>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public infix fun </*0*/ R> kotlin.UIntArray.zip(/*0*/ other: kotlin.collections.Iterable<R>): kotlin.collections.List<kotlin.Pair<kotlin.UInt, R>>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ R, /*1*/ V> kotlin.UIntArray.zip(/*0*/ other: kotlin.collections.Iterable<R>, /*1*/ transform: (a: kotlin.UInt, b: R) -> V): kotlin.collections.List<V>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public infix fun </*0*/ R> kotlin.ULongArray.zip(/*0*/ other: kotlin.Array<out R>): kotlin.collections.List<kotlin.Pair<kotlin.ULong, R>>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ R, /*1*/ V> kotlin.ULongArray.zip(/*0*/ other: kotlin.Array<out R>, /*1*/ transform: (a: kotlin.ULong, b: R) -> V): kotlin.collections.List<V>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public infix fun kotlin.ULongArray.zip(/*0*/ other: kotlin.ULongArray): kotlin.collections.List<kotlin.Pair<kotlin.ULong, kotlin.ULong>>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ V> kotlin.ULongArray.zip(/*0*/ other: kotlin.ULongArray, /*1*/ transform: (a: kotlin.ULong, b: kotlin.ULong) -> V): kotlin.collections.List<V>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public infix fun </*0*/ R> kotlin.ULongArray.zip(/*0*/ other: kotlin.collections.Iterable<R>): kotlin.collections.List<kotlin.Pair<kotlin.ULong, R>>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ R, /*1*/ V> kotlin.ULongArray.zip(/*0*/ other: kotlin.collections.Iterable<R>, /*1*/ transform: (a: kotlin.ULong, b: R) -> V): kotlin.collections.List<V>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public infix fun </*0*/ R> kotlin.UShortArray.zip(/*0*/ other: kotlin.Array<out R>): kotlin.collections.List<kotlin.Pair<kotlin.UShort, R>>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ R, /*1*/ V> kotlin.UShortArray.zip(/*0*/ other: kotlin.Array<out R>, /*1*/ transform: (a: kotlin.UShort, b: R) -> V): kotlin.collections.List<V>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public infix fun kotlin.UShortArray.zip(/*0*/ other: kotlin.UShortArray): kotlin.collections.List<kotlin.Pair<kotlin.UShort, kotlin.UShort>>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ V> kotlin.UShortArray.zip(/*0*/ other: kotlin.UShortArray, /*1*/ transform: (a: kotlin.UShort, b: kotlin.UShort) -> V): kotlin.collections.List<V>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public infix fun </*0*/ R> kotlin.UShortArray.zip(/*0*/ other: kotlin.collections.Iterable<R>): kotlin.collections.List<kotlin.Pair<kotlin.UShort, R>>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ R, /*1*/ V> kotlin.UShortArray.zip(/*0*/ other: kotlin.collections.Iterable<R>, /*1*/ transform: (a: kotlin.UShort, b: R) -> V): kotlin.collections.List<V>
public infix fun </*0*/ T, /*1*/ R> kotlin.collections.Iterable<T>.zip(/*0*/ other: kotlin.Array<out R>): kotlin.collections.List<kotlin.Pair<T, R>>
public inline fun </*0*/ T, /*1*/ R, /*2*/ V> kotlin.collections.Iterable<T>.zip(/*0*/ other: kotlin.Array<out R>, /*1*/ transform: (a: T, b: R) -> V): kotlin.collections.List<V>
public infix fun </*0*/ T, /*1*/ R> kotlin.collections.Iterable<T>.zip(/*0*/ other: kotlin.collections.Iterable<R>): kotlin.collections.List<kotlin.Pair<T, R>>
public inline fun </*0*/ T, /*1*/ R, /*2*/ V> kotlin.collections.Iterable<T>.zip(/*0*/ other: kotlin.collections.Iterable<R>, /*1*/ transform: (a: T, b: R) -> V): kotlin.collections.List<V>
@kotlin.SinceKotlin(version = "1.2") public fun </*0*/ T> kotlin.collections.Iterable<T>.zipWithNext(): kotlin.collections.List<kotlin.Pair<T, T>>
@kotlin.SinceKotlin(version = "1.2") public inline fun </*0*/ T, /*1*/ R> kotlin.collections.Iterable<T>.zipWithNext(/*0*/ transform: (a: T, b: T) -> R): kotlin.collections.List<R>

@kotlin.SinceKotlin(version = "1.1") public abstract class AbstractCollection</*0*/ out E> : kotlin.collections.Collection<E> {
    /*primary*/ protected constructor AbstractCollection</*0*/ out E>()
    public abstract override /*1*/ val size: kotlin.Int
        public abstract override /*1*/ fun <get-size>(): kotlin.Int
    public open override /*1*/ fun contains(/*0*/ element: E): kotlin.Boolean
    public open override /*1*/ fun containsAll(/*0*/ elements: kotlin.collections.Collection<E>): kotlin.Boolean
    public open override /*1*/ fun isEmpty(): kotlin.Boolean
    public abstract override /*1*/ fun iterator(): kotlin.collections.Iterator<E>
    @kotlin.js.JsName(name = "toArray") protected open fun toArray(): kotlin.Array<kotlin.Any?>
    protected open fun </*0*/ T> toArray(/*0*/ array: kotlin.Array<T>): kotlin.Array<T>
    public open override /*1*/ fun toString(): kotlin.String
}

public abstract class AbstractIterator</*0*/ T> : kotlin.collections.Iterator<T> {
    /*primary*/ public constructor AbstractIterator</*0*/ T>()
    protected abstract fun computeNext(): kotlin.Unit
    protected final fun done(): kotlin.Unit
    public open override /*1*/ fun hasNext(): kotlin.Boolean
    public open override /*1*/ fun next(): T
    protected final fun setNext(/*0*/ value: T): kotlin.Unit
}

@kotlin.SinceKotlin(version = "1.1") public abstract class AbstractList</*0*/ out E> : kotlin.collections.AbstractCollection<E>, kotlin.collections.List<E> {
    /*primary*/ protected constructor AbstractList</*0*/ out E>()
    public abstract override /*2*/ val size: kotlin.Int
        public abstract override /*2*/ fun <get-size>(): kotlin.Int
    public open override /*2*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
    public abstract override /*1*/ fun get(/*0*/ index: kotlin.Int): E
    public open override /*2*/ fun hashCode(): kotlin.Int
    public open override /*1*/ fun indexOf(/*0*/ element: E): kotlin.Int
    public open override /*2*/ fun iterator(): kotlin.collections.Iterator<E>
    public open override /*1*/ fun lastIndexOf(/*0*/ element: E): kotlin.Int
    public open override /*1*/ fun listIterator(): kotlin.collections.ListIterator<E>
    public open override /*1*/ fun listIterator(/*0*/ index: kotlin.Int): kotlin.collections.ListIterator<E>
    public open override /*1*/ fun subList(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.collections.List<E>
}

@kotlin.SinceKotlin(version = "1.1") public abstract class AbstractMap</*0*/ K, /*1*/ out V> : kotlin.collections.Map<K, V> {
    /*primary*/ protected constructor AbstractMap</*0*/ K, /*1*/ out V>()
    public open override /*1*/ val keys: kotlin.collections.Set<K>
        public open override /*1*/ fun <get-keys>(): kotlin.collections.Set<K>
    public open override /*1*/ val size: kotlin.Int
        public open override /*1*/ fun <get-size>(): kotlin.Int
    public open override /*1*/ val values: kotlin.collections.Collection<V>
        public open override /*1*/ fun <get-values>(): kotlin.collections.Collection<V>
    public open override /*1*/ fun containsKey(/*0*/ key: K): kotlin.Boolean
    public open override /*1*/ fun containsValue(/*0*/ value: V): kotlin.Boolean
    public open override /*1*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
    public open override /*1*/ fun get(/*0*/ key: K): V?
    public open override /*1*/ fun hashCode(): kotlin.Int
    public open override /*1*/ fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun toString(): kotlin.String
}

public abstract class AbstractMutableCollection</*0*/ E> : kotlin.collections.AbstractCollection<E>, kotlin.collections.MutableCollection<E> {
    /*primary*/ protected constructor AbstractMutableCollection</*0*/ E>()
    public abstract override /*1*/ fun add(/*0*/ element: E): kotlin.Boolean
    public open override /*1*/ fun addAll(/*0*/ elements: kotlin.collections.Collection<E>): kotlin.Boolean
    public open override /*1*/ fun clear(): kotlin.Unit
    public open override /*1*/ fun remove(/*0*/ element: E): kotlin.Boolean
    public open override /*1*/ fun removeAll(/*0*/ elements: kotlin.collections.Collection<E>): kotlin.Boolean
    public open override /*1*/ fun retainAll(/*0*/ elements: kotlin.collections.Collection<E>): kotlin.Boolean
    @kotlin.js.JsName(name = "toJSON") public open fun toJSON(): kotlin.Any
}
