/*
 * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package generators

import java.io.*
import templates.*
import templates.TemplateWriter

/**
 * Generates methods in the standard library which are mostly identical
 * but just using a different input kind.
 *
 * Kinda like mimicking source macros here, but this avoids the inefficiency of type conversions
 * at runtime.
 */
fun main(args: Array<String>) {
    val templateGroups = sequenceOf(
        Elements,
        Filtering,
        Ordering,
        ArrayOps,
        Snapshots,
        Mapping,
        SetOps,
        Aggregates,
        Guards,
        Generators,
        StringJoinOps,
        SequenceOps,
        RangeOps,
        Numeric,
        ComparableOps
    )

    templateGroups.generateSources(args, StandardLibGeneratorStrategy())
}

private class StandardLibGeneratorStrategy : SourceGeneratorStrategy<MemberBuilder> {
    override val supportedTargets: List<KotlinTarget>
        get() = KotlinTarget.values - KotlinTarget.Native

    override fun baseDir(target: KotlinTarget): String = when (target) {
        KotlinTarget.Common -> "libraries/stdlib/common/src/generated"
        KotlinTarget.JVM -> "libraries/stdlib/jvm/src/generated"
        KotlinTarget.JS -> "libraries/stdlib/js/src/generated"
        KotlinTarget.JS_IR -> "libraries/stdlib/js-ir/src/generated"
        else -> error("Invalid target: $target")
    }

    override fun fileName(target: KotlinTarget, source: SourceFile): String {
        val platformSuffix = if (target.platform == Platform.Common) "" else target.platform.name.toLowerCase().capitalize()
        return "_${source.name.capitalize()}$platformSuffix.kt"
    }

    override val writer: TemplateWriter<MemberBuilder>
        get() = MemberWriter()
}

private class MemberWriter : TemplateWriter<MemberBuilder> {
    override fun writeTo(file: File, builders: List<MemberBuilder>, targetedSource: TargetedSourceFile) {
        val (target, sourceFile) = targetedSource
        println("Generating file: $file")
        file.parentFile.mkdirs()
        FileWriter(file).use { writer ->
            writer.appendln(copyrightNotice())

            when (target.platform) {
                Platform.Common, Platform.JVM -> {
                    if (sourceFile.multifile) {
                        writer.appendln("@file:kotlin.jvm.JvmMultifileClass")
                    }

                    writer.appendln("@file:kotlin.jvm.JvmName(\"${sourceFile.jvmClassName}\")")
                    sourceFile.jvmPackageName?.let {
                        writer.appendln("@file:kotlin.jvm.JvmPackageName(\"$it\")")
                    }
                    writer.appendln()
                }
            }

            writer.append("package ${sourceFile.packageName ?: "kotlin"}\n\n")
            writer.append("${autogeneratedWarning("GenerateStandardLib.kt")}\n\n")
            if (target.platform == Platform.JS) {
                writer.appendln("import kotlin.js.*")
                if (sourceFile == SourceFile.Arrays) {
                    writer.appendln("import primitiveArrayConcat")
                    writer.appendln("import withType")
                }
            }
            if (target.platform == Platform.Common) {
                writer.appendln("import kotlin.random.*")
            }
            if (sourceFile.packageName == "kotlin.collections") {
                writer.appendln("import kotlin.ranges.contains")
                writer.appendln("import kotlin.ranges.reversed")
            }

            writer.appendln()

            for (f in builders) {
                f.build(writer)
            }
        }
    }
}
