/*
 * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package templates

import org.xml.sax.InputSource
import java.io.File
import java.io.Reader
import javax.xml.xpath.XPathFactory
import kotlin.system.exitProcess

fun autogeneratedWarning(generator: String): String = """//
// NOTE: THIS FILE IS AUTO-GENERATED by the $generator
// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib
//"""


private var copyrightNotice: String? = null

fun copyrightNotice(): String {
    val cur = copyrightNotice
    return if (cur == null) {
        val new = readCopyrightNoticeFromProfile { Thread.currentThread().contextClassLoader.getResourceAsStream("apache.xml").reader() }
        copyrightNotice = new
        return new
    } else cur
}

private fun readCopyrightNoticeFromProfile(getCopyrightReader: () -> Reader): String {
    val template = getCopyrightReader().use { reader ->
        XPathFactory.newInstance().newXPath().evaluate("/component/copyright/option[@name='notice']/@value", InputSource(reader))
    }
    val yearTemplate = "&#36;today.year"
    val year = java.time.LocalDate.now().year.toString()
    assert(yearTemplate in template)

    return template.replace(yearTemplate, year).lines().joinToString("", prefix = "/*\n", postfix = " */\n") { " * $it\n" }
}


interface SourceGeneratorStrategy<TBuilder> {
    val supportedTargets: List<KotlinTarget>
    fun baseDir(target: KotlinTarget): String
    fun fileName(target: KotlinTarget, source: SourceFile): String
    val writer: TemplateWriter<TBuilder>
}

interface TemplateWriter<TBuilder> {
    fun writeTo(file: File, builders: List<TBuilder>, targetedSource: TargetedSourceFile)
}

data class TargetedSourceFile(
    val target: KotlinTarget,
    val sourceFile: SourceFile
)


fun <TBuilder : TemplateBuilderBase> Sequence<TemplateGroup<TBuilder>>.generateSources(args: Array<String>, strategy: SourceGeneratorStrategy<TBuilder>) {
    val targetBaseDirs = parseTargetBaseDirs(args, strategy)

    this.groupByFileAndWriteWith(writer = strategy.writer, targetsToGenerate = targetBaseDirs.keys) { (target, source) ->
        val targetDir = targetBaseDirs[target] ?: error("Target $target directory is not configured")
        val fileName = strategy.fileName(target, source)
        targetDir.resolve(fileName)
    }
}

private fun parseTargetBaseDirs(args: Array<String>, strategy: SourceGeneratorStrategy<*>): Map<KotlinTarget, File> = when (args.size) {
    1 -> {
        val baseDir = File(args.first())
        val targetsToGenerate = strategy.supportedTargets
        targetsToGenerate.associateWith { baseDir.resolveExistingDir(strategy.baseDir(it)) }
    }
    2 -> {
        val (targetName, targetDir) = args
        val target = KotlinTarget.values.singleOrNull { it.name.equals(targetName, ignoreCase = true) } ?: error("Invalid target: $targetName")
        mapOf(target to File(targetDir).also { it.requireExistingDir() })
    }
    else -> {
        println(
            """
            Parameters:
            <kotlin-base-dir> - generates sources for common, jvm, js, ir-js targets using paths derived from specified base path
            <target> <target-dir> - generates source for the specified target in the specified target directory
            """
        )
        exitProcess(1)
    }
}

private fun File.resolveExistingDir(subpath: String) = resolve(subpath).also { it.requireExistingDir() }

private fun File.requireExistingDir() {
    require(isDirectory) { "Directory $this doesn't exist"}
}

private fun <TBuilder : TemplateBuilderBase> Sequence<TemplateGroup<TBuilder>>.groupByFileAndWriteWith(
    writer: TemplateWriter<TBuilder>,
    targetsToGenerate: Collection<KotlinTarget>,
    fileNameBuilder: (TargetedSourceFile) -> File
) {
    flatMap { group ->
        group.invoke()
                .flatMap { it.instantiate(targetsToGenerate) }
                .sortedBy { it.sortingSignature }
    }.groupByFileAndWriteWith(writer, fileNameBuilder)
}

private fun <TBuilder : TemplateBuilderBase> Sequence<TBuilder>.groupByFileAndWriteWith(
    writer: TemplateWriter<TBuilder>,
    fileNameBuilder: (TargetedSourceFile) -> File
) {
    val groupedBuilders = groupBy { TargetedSourceFile(it.target, it.sourceFile) }

    for ((psf, builders) in groupedBuilders) {
        val file = fileNameBuilder(psf)
        writer.writeTo(file, builders, psf)
    }
}
