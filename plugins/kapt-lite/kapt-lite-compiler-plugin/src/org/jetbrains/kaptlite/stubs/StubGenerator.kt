/*
 * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kaptlite.stubs

import org.jetbrains.kaptlite.stubs.model.JavaClassStub
import org.jetbrains.kaptlite.stubs.util.append
import org.jetbrains.kotlin.cli.common.CLIConfigurationKeys
import org.jetbrains.kotlin.cli.jvm.config.JvmClasspathRoot
import org.jetbrains.kotlin.codegen.state.GenerationState
import org.jetbrains.kotlin.diagnostics.DiagnosticSink
import org.jetbrains.kotlin.resolve.jvm.diagnostics.JvmDeclarationOrigin
import org.jetbrains.org.objectweb.asm.tree.ClassNode
import java.io.Closeable

class StubGenerator(
    diagnostics: DiagnosticSink,
    compiledClasses: List<ClassNode>,
    origins: Map<Any, JvmDeclarationOrigin>,
    state: GenerationState
) : Closeable {
    private val compiledFilesInput = CompiledFilesGeneratorInput(compiledClasses)

    private val classpathInputs = run {
        val contentRoots = state.configuration[CLIConfigurationKeys.CONTENT_ROOTS] ?: emptyList()
        val classpathRoots = contentRoots.filterIsInstance<JvmClasspathRoot>()
        classpathRoots.map { if (it.file.isDirectory) DirectoryGeneratorInput(it.file) else JarGeneratorInput(it.file) }
    }

    private val inputs = listOf(compiledFilesInput) + classpathInputs

    private val loader = ClassFileLoader(inputs)
    private val context = StubGeneratorContext(loader, diagnostics, state, origins)

    fun generate(output: GeneratorOutput) {
        compiledFilesInput.iterate { classFile ->
            generate(classFile, output)
        }
    }

    override fun close() {
        inputs.forEach { it.close() }
    }

    private fun generate(file: ClassFile, output: GeneratorOutput) {
        val cls = parse(file) ?: return
        output(file.internalName, cls, output)
    }

    private fun parse(file: ClassFile): JavaClassStub? {
        val node = context.loader.load(file.internalName) ?: return null
        for (innerClass in node.innerClasses) {
            if (innerClass.name == file.internalName) {
                // Only top-level classes should be parsed
                return null
            }
        }

        return JavaClassStub.parse(context, node, JavaClassStub.NestingKind.TOP_LEVEL)
    }

    private fun output(internalName: String, cls: JavaClassStub, output: GeneratorOutput) {
        val targetDirPath = cls.name.packageName.replace('.', '/')
        val targetFilePath = (if (targetDirPath.isEmpty()) "" else "$targetDirPath/") + cls.name.className + ".java"

        output.produce(internalName, targetFilePath) {
            append("/**").newLine()
            append(" * This file was generated by the kapt-lite stub generator.").newLine()
            append(" * Do not change it manually.").newLine()
            append(" */").newLine()

            if (cls.name.packageName.isNotEmpty()) {
                append("package ").append(cls.name.packageName).append(';')
                newLine().newLine()
            } else {
                // We have to add package/import directives before declarations.
                // Otherwise, the file comment will become a class one.
                append("import java.lang.Object;")
                newLine().newLine()
            }

            append(cls)
        }
    }
}